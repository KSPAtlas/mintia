# Note on signals and killing threads

I've found the NT-like usermode APC and thread termination mechanism to be unsatisfactory on its own. Therefore, I've jotted own some notes on a possible alternative implementation below.

A mechanism akin to unix-like signals will be implemented with a usermode APC targeted at a signal dispatcher function in OSDLL.dll, with a signal number as one of the context arguments. Unlike in NT, all usermode waits will be ALERTABLE (i.e. wait alertability will only be an internal argument, not even exposed in the syscall interface) *unless* the thread has entered a critical section. Also unlike NT, usermode APCs will always be delivered to a thread immediately upon return to executing userspace code, again *unless* the thread has entered a critical section.

Killing a thread will work more like it does in AISIX than it does in the NT kernel, for responsiveness reasons. Namely, signalling or killing a thread will set a flag called something like `Signalled` in its TCB. Alertability for kernel mode waits takes a new meaning: can it be interrupted, in order to kill the thread or to deliver a signal? The answer should be "yes" in most cases. When a thread is in an alertable kernel mode wait when a signal is generated, or the thread is killed, it will be awoken with STATUS_SIGNALLED or STATUS_KILLED respectively. A thread can avoid being awoken by a signal by being in an UNALERTABLE usermode wait (i.e. by being in a critical section), but being killed will always result in a wakeup from usermode waits.

After the `Signalled` flag is set to either SIGNALLED or KILLED, any attempt to perform any usermode wait or any ALERTABLE kernel mode wait will immediately return with STATUS_SIGNALLED or STATUS_KILLED respectively. The exception to this is if the `CleaningUp` flag is set, which indicates the thread is exiting and cleaning up after itself and needs to execute normally.

When `Signalled` is set to SIGNALLED, the thread will be rigged to jump to the OSDLL.dll signal dispatcher upon return to userspace, either through the queuing of a usermode APC or by some specialized mechanism. However, if it is set to KILLED, the thread will exit, performing any cleanup with the `CleaningUp` flag set. It will then ditch existence forever, leaving its corpse to be cleaned up by the reaper thread.

## Main thread

Processes will have a "main thread". Threads will be signal-able on their own once you have acquired a handle to one with the EXEC permission, but processes themselves also need to be signalled. This will be accomplished by delivering the signal to the "main thread", which is just the initial thread the process is created with. If the main thread of a process terminates, all other threads in the process are terminated and the process exits.
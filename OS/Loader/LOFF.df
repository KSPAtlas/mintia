#include "<df>/dragonfruit.h"
#include "<ll>/rta3x/a3x.h"
#include "loader.h"

struct LOFFHeader
	4 Magic
	4 SymbolTableOffset
	4 SymbolCount
	4 StringTableOffset
	4 StringTableSize
	4 TargetArchitecture
	4 EntrySymbol
	4 Stripped
	28 Reserved
	4 TextHeader
	4 DataHeader
	4 BSSHeader
endstruct

struct LOFFSectionHeader
	4 FixupTableOffset
	4 FixupCount
	4 SectionOffset
	4 SectionSize
	4 LinkedAddress
endstruct

struct LOFFSymbol
	4 NameOffset
	4 Section
	4 Type
	4 Value
endstruct

const LOFFMagic 0x4C4F4633
const LOFFArch 2

const LOFFGLOBAL 1

const LOFFTEXT 1

buffer LOFFHeaderBuf LOFFHeader_SIZEOF

buffer LOFFSymbolBuf LOFFSymbol_SIZEOF

fn HexDump { addr len -- }
	auto i
	0 i!

	while (len@)
		if (i@ 4 % 0 == i@ &&)
			'\n' Putc
		end

		addr@ @ "%9x " Printf

		1 i +=
		4 addr +=
		4 len -=
	end
end

fn LOFFLoad { path -- sz entry }
	-1 entry!

	auto ino
	path@ AFSPath ino!

	if (ino@ -1 ==)
		"not found\n" Printf
		return
	end

	if (ino@ AFSINode_Type + @ 1 ~=)
		ino@ AFSFreeINode
		-1 ino!
		"is a directory\n" Printf
		return
	end

	auto bytes
	LOFFHeaderBuf LOFFHeader_SIZEOF 0 ino@ AFSRead bytes!

	if (bytes@ LOFFHeader_SIZEOF ~=)
		ino@ AFSFreeINode
		-1 entry!
		"short executable or error\n" Printf
		return
	end

	if (LOFFHeaderBuf LOFFHeader_Magic + @ LOFFMagic ~=)
		ino@ AFSFreeINode
		-1 entry!
		"corrupt executable\n" Printf
		return
	end

	if (LOFFHeaderBuf LOFFHeader_TargetArchitecture + @ LOFFArch ~=)
		ino@ AFSFreeINode
		-1 entry!
		"executable is not for this architecture\n" Printf
		return
	end

	// having passed basic checks to make sure its not a text file or something, just trust it now

	auto text

	// load text section

	0
	LOFFHeaderBuf LOFFHeader_TextHeader + @
	ino@ LOFFLoadSection entry! text! drop

	if (entry@ 0 ~=)
		ino@ AFSFreeINode
		-1 entry!
		return
	end

	// load data section

	0
	LOFFHeaderBuf LOFFHeader_DataHeader + @
	ino@ LOFFLoadSection entry! drop drop

	if (entry@ 0 ~=)
		ino@ AFSFreeINode
		-1 entry!
		return
	end

	// load bss section

	1
	LOFFHeaderBuf LOFFHeader_BSSHeader + @
	ino@ LOFFLoadSection entry! drop sz!

	if (entry@ 0 ~=)
		ino@ AFSFreeINode
		-1 entry!
		return
	end

	LOFFHeaderBuf LOFFHeader_EntrySymbol + @ entry!

	if (entry@ 0xFFFFFFFF ~=) // if there is an entrypoint symbol,
		auto symoff
		LOFFHeaderBuf LOFFHeader_SymbolTableOffset + @ symoff!

		entry@ LOFFSymbol_SIZEOF * symoff +=

		LOFFSymbolBuf LOFFSymbol_SIZEOF symoff@ ino@ AFSRead bytes! // read the entry symbol

		if (bytes@ LOFFSymbol_SIZEOF ~=)
			ino@ AFSFreeINode
			"short entry symbol or error\n" Printf
			-1 entry!
			return
		end

		LOFFSymbolBuf LOFFSymbol_Value + @ text@ + entry! // get its value
	end else
		0 entry! // no entry symbol
	end

	text@ sz -=

	ino@ AFSFreeINode
end

buffer LOFFSectionHeaderBuf LOFFSectionHeader_SIZEOF

fn LOFFLoadSection { bss header ino -- endp la ok }
	LOFFSectionHeaderBuf LOFFSectionHeader_SIZEOF header@ ino@ AFSRead ok!

	if (ok@ LOFFSectionHeader_SIZEOF ~=)
		-1 ok!
		"short section header or error\n" Printf
		return
	end

	LOFFSectionHeaderBuf LOFFSectionHeader_LinkedAddress + @ la!

	// make sure not to load this section over the top of us or the firmware

	if (la@ 0x50000 <) // XXX platform specific
		-1 ok!
		la@ "section address 0x%x < 0x50000\n" Printf
		return
	end

	auto sz
	LOFFSectionHeaderBuf LOFFSectionHeader_SectionSize + @ sz!

	0 ok!

	if (bss@)
		la@ sz@ 0 memset
	end else
		auto offset
		LOFFSectionHeaderBuf LOFFSectionHeader_SectionOffset + @ offset!

		la@ sz@ offset@ ino@ AFSRead ok!

		if (ok@ sz@ ~=)
			-1 ok!
			"short section or error\n" Printf
			return
		end

		0 ok!
	end

	la@ sz@ + endp!
end
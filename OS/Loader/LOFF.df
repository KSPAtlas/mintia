#include "<df>/dragonfruit.h"
#include "<ll>/rta3x/a3x.h"
#include "loader.h"

const LOFFMagic 0x4C4F4634
const LOFFArch 2

const LOFFTEXT 1

buffer LOFFHeaderBuf LOFFHeader_SIZEOF

fn LOFFLoad { path loff -- ok }
	-1 ok!

	auto ino
	path@ AFSPath ino!

	if (ino@ -1 ==)
		"not found\n" Printf
		return
	end

	if (ino@ AFSINode_Type + @ 1 ~=)
		ino@ AFSFreeINode
		"is a directory\n" Printf
		return
	end

	auto bytes
	LOFFHeaderBuf LOFFHeader_SIZEOF 0 ino@ AFSRead bytes!

	if (bytes@ LOFFHeader_SIZEOF ~=)
		ino@ AFSFreeINode
		"short executable or error\n" Printf
		return
	end

	if (LOFFHeaderBuf LOFFHeader_Magic + @ LOFFMagic ~=)
		ino@ AFSFreeINode
		"corrupt executable\n" Printf
		return
	end

	if (LOFFHeaderBuf LOFFHeader_TargetArchitecture + @ LOFFArch ~=)
		ino@ AFSFreeINode
		"executable is not for this architecture\n" Printf
		return
	end

	LOFFHeaderBuf LOFFHeader_EntrySymbol + @ loff@ LOFFLoaded_EntrySymbol + !

	// having passed basic checks to make sure its not a text file or something, just trust it now

	// load text section

	loff@ LOFFLoaded_TextLinkedAddr +
	0
	LOFFHeaderBuf LOFFHeader_TextHeader + @
	ino@ LOFFLoadSection ok!

	if (ok@ 0 ~=)
		ino@ AFSFreeINode
		return
	end

	// load data section

	loff@ LOFFLoaded_DataLinkedAddr +
	0
	LOFFHeaderBuf LOFFHeader_DataHeader + @
	ino@ LOFFLoadSection ok!

	if (ok@ 0 ~=)
		ino@ AFSFreeINode
		return
	end

	// load bss section

	loff@ LOFFLoaded_BSSLinkedAddr +
	1
	LOFFHeaderBuf LOFFHeader_BSSHeader + @
	ino@ LOFFLoadSection ok!

	if (ok@ 0 ~=)
		ino@ AFSFreeINode
		return
	end

	loff@ ino@ LOFFLoadTables ok!
	if (ok@ 0 ~=)
		ino@ AFSFreeINode
		return
	end

	ino@ AFSFreeINode
end

fn LOFFGetString { loff offset -- str }
	auto strtab
	loff@ LOFFLoaded_StringTable + @ strtab!

	if (strtab@ ~~)
		"no string table\n" LoaderPanic
		return
	end

	strtab@ offset@ + str!
end

fn LOFFLoadTables { loff ino -- ok }
	auto count
	LOFFHeaderBuf LOFFHeader_SymbolCount + @ count!

	count@ loff@ LOFFLoaded_SymbolCount + !

	auto offset

	auto bytes

	auto ptr

	if (count@)
		LOFFHeaderBuf LOFFHeader_SymbolTableOffset + @ offset!

		count@ LOFFSymbol_SIZEOF * bytes!

		bytes@ 4095 + 12 >> 0 MemAlloc ok! ptr!

		if (ok@)
			"couldn't allocate memory for symbol table\n" Printf
			return
		end

		12 ptr <<=

		ptr@ bytes@ offset@ ino@ AFSRead ok!

		if (ok@ bytes@ ~=)
			"short symtab or error\n" Printf
			-1 ok!
			return
		end

		ptr@ loff@ LOFFLoaded_SymbolTable + !
	end

	LOFFHeaderBuf LOFFHeader_StringTableSize + @ bytes!

	bytes@ loff@ LOFFLoaded_StringSize + !

	auto strtab
	0 strtab!

	if (bytes@)
		LOFFHeaderBuf LOFFHeader_StringTableOffset + @ offset!

		bytes@ 4095 + 12 >> 0 MemAlloc ok! ptr!

		if (ok@)
			"couldn't allocate memory for string table\n" Printf
			return
		end

		12 ptr <<=

		ptr@ bytes@ offset@ ino@ AFSRead ok!

		if (ok@ bytes@ ~=)
			"short string table or error\n" Printf
			-1 ok!
			return
		end

		ptr@ strtab!
		ptr@ loff@ LOFFLoaded_StringTable + !
	end

	LOFFHeaderBuf LOFFHeader_ImportCount + @ count!

	count@ loff@ LOFFLoaded_ImportCount + !

	auto pages

	if (count@)
		LOFFHeaderBuf LOFFHeader_ImportTableOffset + @ offset!

		count@ LOFFImport_SIZEOF * bytes!

		bytes@ 4095 + 12 >> pages!

		pages@ 0 MemAlloc ok! ptr!

		if (ok@)
			"couldn't allocate memory for import table\n" Printf
			return
		end

		12 ptr <<=

		ptr@ bytes@ offset@ ino@ AFSRead ok!

		if (ok@ bytes@ ~=)
			"short import table or error\n" Printf
			-1 ok!
			return
		end

		ptr@ loff@ LOFFLoaded_ImportTable + !
	end

	0 ok!
end

buffer LOFFSectionHeaderBuf LOFFSectionHeader_SIZEOF

fn LOFFLoadSection { section bss header ino -- ok }
	LOFFSectionHeaderBuf LOFFSectionHeader_SIZEOF header@ ino@ AFSRead ok!

	if (ok@ LOFFSectionHeader_SIZEOF ~=)
		-1 ok!
		"short section header or error\n" Printf
		return
	end

	auto la
	LOFFSectionHeaderBuf LOFFSectionHeader_LinkedAddress + @ la!

	if (la@ 4095 &)
		-1 ok!
		"unaligned section\n" Printf
		return
	end

	auto sz
	LOFFSectionHeaderBuf LOFFSectionHeader_SectionSize + @ sz!

	auto astart

	if (sz@)
		sz@ 4095 + 12 >> la@ 12 >> MemAlloc ok! astart!

		if (ok@)
			"couldn't allocate memory for section\n" Printf
			return
		end

		12 astart <<=
	end

	la@ section@ LOFFLoadedSection_LinkedAddr + !
	astart@ section@ LOFFLoadedSection_RealAddr + !
	sz@ section@ LOFFLoadedSection_Size + !

	0 ok!

	if (sz@)
		if (bss@)
			astart@ sz@ 0 memset // bss section, just zero it out
		end else
			auto offset

			auto count
			LOFFSectionHeaderBuf LOFFSectionHeader_FixupCount + @ count!

			if (count@)
				LOFFSectionHeaderBuf LOFFSectionHeader_FixupTableOffset + @ offset!

				auto bsw
				count@ LOFFSectionHeader_SIZEOF * bsw!

				auto qp
				bsw@ 4095 + 12 >> 0 MemAlloc ok! qp!

				if (ok@)
					"couldn't allocate memory for fixup table\n" Printf
					return
				end

				12 qp <<=

				qp@ bsw@ offset@ ino@ AFSRead ok!

				if (ok@ bsw@ ~=)
					-1 ok!
					"short fixup table or error\n" Printf
					return
				end

				qp@ section@ LOFFLoadedSection_FixupTable + !
				count@ section@ LOFFLoadedSection_FixupCount + !
			end

			LOFFSectionHeaderBuf LOFFSectionHeader_SectionOffset + @ offset!

			astart@ sz@ offset@ ino@ AFSRead ok! // read the section into memory

			if (ok@ sz@ ~=)
				-1 ok!
				"short section or error\n" Printf
				return
			end

			0 ok!
		end
	end
end
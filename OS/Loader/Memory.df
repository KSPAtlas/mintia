#include "<df>/dragonfruit.h"
#include "Loader.h"

buffer MemBitmap INITBITMAPSZ
public MemBitmap

var MemAllocated 0
public MemAllocated

var MemPages 0
public MemPages

var MemPageFrameDB 0
public MemPageFrameDB

var MemHeap 0
public MemHeap

var MemHeapSize 0
public MemHeapSize

const HEAPMAXDEFAULT (2048 1024 *)

const HEAPMINDEFAULT (32 1024 *)

const HEAPSHFDEFAULT 4

fn MemInit { -- }
	auto bm
	MemBitmap bm!

	auto pages
	LoaderTotalRAM@ 12 >> pages!

	// limit to first 64MB as thats the size of a limn2k jump segment
	pages@ 16384 min MemPages!

	// reserve loader code and data

	// XXX this only works because a3x firmware and bootloader data are
	// contiguous and start at 0x0

	auto ldrtop
	pointerof _bss_end ldrtop!

	1 ldrtop@ 4095 + 12 >> 0 MemSetStatus

	// allocate these before we fragment physical memory by loading OS modules

	auto rps

	// allocate pageframe DB

	pages@ 32 * rps!

	rps@ "pageframe db is %d bytes" Printf

	auto astart

	auto ok
	rps@ 4095 + 12 >> 0 MemAlloc ok! astart!

	if (ok@)
		"couldn't allocate pageframe db\n" LoaderPanic
	end

	astart@ 12 << MemPageFrameDB!

	MemPageFrameDB@ " at 0x%08x\n" Printf

	// allocate kernel heap

	auto heapmax
	"HEAPMAX" ArgsValue heapmax!

	if (heapmax@)
		heapmax@ atoi 1024 * heapmax!
	end else
		HEAPMAXDEFAULT heapmax!
	end

	auto heapmin
	"HEAPMIN" ArgsValue heapmin!

	if (heapmin@)
		heapmin@ atoi 1024 * heapmin!
	end else
		HEAPMINDEFAULT heapmin!
	end

	auto heapshf
	"HEAPSHF" ArgsValue heapshf!

	if (heapshf@)
		heapshf@ atoi heapshf!
	end else
		HEAPSHFDEFAULT heapshf!
	end

	pages@ heapshf@ >> 12 << rps!

	// round down to nearest power of two

	rps@ 1 >> rps |=
	rps@ 2 >> rps |=
	rps@ 4 >> rps |=
	rps@ 8 >> rps |=
	rps@ 16 >> rps |=
	rps@ 1 >> rps -=

	if (rps@ heapmin@ <)
		heapmin@ rps!
	end elseif (rps@ heapmax@ >)
		heapmax@ rps!
	end

	rps@ 4095 + 12 >> rps!

	rps@ 12 << "heap is %d bytes" Printf

	rps@ 0 MemAlloc ok! astart!

	if (ok@)
		"\ncouldn't allocate kernel heap\n" LoaderPanic
	end

	astart@ 12 << MemHeap!
	rps@ 12 << MemHeapSize!

	MemHeap@ " at 0x%08x\n" Printf
end

fn HexDump { addr len -- }
	auto i
	0 i!

	while (len@)
		if (i@ 4 % 0 == i@ &&)
			'\n' Putc
		end

		addr@ @ "%9x " Printf

		1 i +=
		4 addr +=
		4 len -=
	end

	'\n' Putc
end

fn MemSetStatus { with pages start -- }
	auto max
	pages@ start@ + max!

	auto bmp
	MemBitmap start@ 32 / 4 * + bmp!

	auto word
	bmp@@ word!

	auto q
	start@ q!

	while (start@ max@ <)
		if (with@)
			word@ start@ 31 & bitset word!
		end else
			word@ start@ 31 & bitclear word!
		end

		1 start +=

		if (start@ 31 & ~~)
			word@ bmp@!

			4 bmp +=

			bmp@@ word!
		end
	end

	word@ bmp@!
end

fn MemFree { pages pstart -- }
	pages@ MemAllocated -=

	0 pages@ pstart@ MemSetStatus
end

fn MemAlloc { pages pstart -- astart ok }
	-1 ok!

	if (pages@ 0 ==)
		"tried to allocate 0 pages\n" LoaderPanic
	end

	auto chend
	MemPages@ chend!

	auto i
	pstart@ i!

	auto bmp
	MemBitmap i@ 32 / 4 * + bmp!

	auto run
	0 run!

	auto mode
	0 mode!

	while (1)
		if (i@ chend@ >=)
			if (mode@)
				-1 ok!
				return
			end else
				0 i!
				1 mode!
				0 run!
				pstart@ chend!
				MemBitmap bmp!
			end
		end

		if (bmp@@ i@ 31 & bitget)
			0 run!
		end else
			if (run@ 0 ==)
				i@ astart!
			end

			1 run +=
		end

		if (run@ pages@ >=)
			1 pages@ astart@ MemSetStatus

			pages@ MemAllocated +=

			0 ok!
			return
		end 

		1 i +=

		if (i@ 31 & ~~)
			4 bmp +=

			if (bmp@@ 0xFFFFFFFF ==)
				32 i +=
				0 run!
				4 bmp +=
			end elseif (bmp@@ 0x00000000 ==)
				if (run@ 0 ==)
					i@ astart!
				end

				32 i +=
				32 run +=
				4 bmp +=
			end
		end
	end
end

fn MemDumpBitmap { -- }
	auto bmp
	MemBitmap bmp!

	auto i
	0 i!

	auto ende
	MemPages@ 1024 min ende!

	while (i@ ende@ <)
		auto bit
		i@ 7 & bit!

		if (bit@ 0 ==)
			'|' Putc
		end

		bmp@ i@ 8 / + gb bit@ bitget bit!

		if (bit@)
			'x' Putc
		end else
			' ' Putc
		end

		1 i +=
	end
end
#include "<df>/dragonfruit.h"
#include "Loader.h"

buffer MemBitmap INITBITMAPSZ
public MemBitmap

var MemAllocated 0
public MemAllocated

var MemPages 0
public MemPages

var MemPageFrameDB 0
public MemPageFrameDB

var MemHeap 0
public MemHeap

var MemHeapSize 0
public MemHeapSize

const HEAPMAXDEFAULT (512 1024 *)

const HEAPMINDEFAULT (32 1024 *)

const HEAPSHFDEFAULT 5

fn MemInit { -- }
	auto bm
	MemBitmap bm!

	auto pages
	LoaderTotalRAM@ 12 >> pages!

	// limit to first 64MB as thats the size of a limn2k jump segment
	pages@ 16384 min MemPages!

	// reserve loader code and data

	// XXX this only works because a3x firmware and bootloader data are
	// contiguous and start at 0x0

	auto ldrtop
	pointerof _bss_end ldrtop!

	1 ldrtop@ 4095 + 12 >> 0 MemSetStatus

	// allocate these before we fragment physical memory by loading OS modules

	auto rps

	// allocate pageframe DB

	pages@ 32 * rps!

	auto astart

	auto ok
	rps@ 4095 + 12 >> 0 MemAlloc ok! astart!

	if (ok@)
		"couldn't allocate pageframe db\n" LoaderPanic
	end

	astart@ 12 << MemPageFrameDB!

	// allocate kernel heap

	auto heapmax
	"HEAPMAX" ArgsValue heapmax!

	if (heapmax@)
		heapmax@ atoi 1024 * heapmax!
	end else
		HEAPMAXDEFAULT heapmax!
	end

	auto heapmin
	"HEAPMIN" ArgsValue heapmin!

	if (heapmin@)
		heapmin@ atoi 1024 * heapmin!
	end else
		HEAPMINDEFAULT heapmin!
	end

	auto heapshf
	"HEAPSHF" ArgsValue heapshf!

	if (heapshf@)
		heapshf@ atoi heapshf!
	end else
		HEAPSHFDEFAULT heapshf!
	end

	pages@ heapshf@ >> 12 << rps!

	if (rps@ heapmin@ <)
		heapmin@ rps!
	end elseif (rps@ heapmax@ >)
		heapmax@ rps!
	end

	rps@ 4095 + 12 >> rps!

	rps@ 12 << "heap is %d bytes\n" Printf

	rps@ 0 MemAlloc ok! astart!

	if (ok@)
		"couldn't allocate kernel heap\n" LoaderPanic
	end

	astart@ 12 << MemHeap!
	rps@ 12 << MemHeapSize!
end

fn HexDump { addr len -- }
	auto i
	0 i!

	while (len@)
		if (i@ 4 % 0 == i@ &&)
			'\n' Putc
		end

		addr@ @ "%9x " Printf

		1 i +=
		4 addr +=
		4 len -=
	end

	'\n' Putc
end

fn MemSetStatus { with pages start -- }
	auto max
	pages@ start@ + max!

	auto bmp
	MemBitmap start@ 32 / 4 * + bmp!

	auto word
	bmp@@ word!

	auto q
	start@ q!

	while (start@ max@ <)
		if (with@)
			word@ start@ 31 & bitset word!
		end else
			word@ start@ 31 & bitclear word!
		end

		1 start +=

		if (start@ 31 & ~~)
			word@ bmp@!

			4 bmp +=

			bmp@@ word!
		end
	end

	word@ bmp@!
end

fn MemFree { pages pstart -- }
	pages@ MemAllocated -=

	0 pages@ pstart@ MemSetStatus
end

fn MemAlloc { pages pstart -- astart ok }
	-1 ok!

	if (pages@ 0 ==)
		"tried to allocate 0 pages\n" LoaderPanic
	end

	auto chend
	MemPages@ chend!

	auto i
	pstart@ i!

	auto bmp
	MemBitmap i@ 32 / 4 * + bmp!

	auto word
	bmp@@ word!

	auto run
	0 run!

	auto mode
	0 mode!

	while (1)
		if (run@ pages@ >=)
			1 pages@ astart@ MemSetStatus

			pages@ MemAllocated +=

			0 ok!
			return
		end elseif (i@ chend@ >=)
			if (mode@)
				-1 ok!
				return
			end else
				0 i!
				1 mode!
				0 run!
				pstart@ chend!
				MemBitmap bmp!
				continue
			end
		end

		if (i@ 31 & ~~)
			bmp@@ word!

			4 bmp +=

			if (word@ 0xFFFFFFFF ==)
				0 run!
				32 i +=
				continue
			end elseif (word@ 0x00000000 ==)
				if (run@ 0 ==)
					i@ astart!
				end

				32 run +=
				32 i +=
				continue
			end
		end

		if (word@ i@ 31 & bitget)
			0 run!
		end else
			if (run@ 0 ==)
				i@ astart!
			end

			1 run +=
		end

		1 i +=
	end
end
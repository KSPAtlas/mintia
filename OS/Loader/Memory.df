#include "<df>/dragonfruit.h"
#include "Loader.h"

buffer MemBitmap INITBITMAPSZ
public MemBitmap

var MemAllocated 0
public MemAllocated

var MemPages 0
public MemPages

var MemPageFrameDB 0
public MemPageFrameDB

var MemPageDirectory 0
public MemPageDirectory

var MemHeap 0
public MemHeap

var MemHeapSize 0
public MemHeapSize

const HEAPMAXDEFAULT (2048 1024 *)

const HEAPMINDEFAULT (32 1024 *)

const HEAPSHFDEFAULT 4

extern MemEnablePaging { -- }

fn MemInit { -- }
	auto bm
	MemBitmap bm!

	auto pages
	LoaderTotalRAM@ 12 >> pages!

	// limit to first 256MB as thats all we have bitmap space for.
	// (LIMNstation only supports this much RAM anyway)
	pages@ 65536 min MemPages!

	// reserve loader code and data

	// XXX this only works because a3x firmware and bootloader data are
	// contiguous and start at 0x0

	auto ldrtop
	pointerof _bss_end ldrtop!

	1 ldrtop@ 4095 + 12 >> 0 MemSetStatus

	auto astart

	auto ok

	1 0 MemAlloc ok! astart!

	if (ok@)
		"couldn't allocate kernel page directory\n" LoaderPanic
	end

	astart@ 12 << MemPageDirectory!

	MemPageDirectory@
	4096
	0
	memset

	// identity map physical memory at 0x00000000

	auto kspc
	IDENTITYSPACE kspc!

	0 astart!

	while (astart@ LoaderTotalRAM@ <)
		astart@ astart@ 0 MemMapPage ok!

		if (ok@)
			"couldn't identity map memory\n" LoaderPanic
		end

		astart@ kspc@ 0 MemMapPage ok!

		if (ok@)
			"couldn't identity map kernel space\n" LoaderPanic
		end

		4096 kspc +=
		4096 astart +=
	end

	MemEnablePaging

	// allocate these before we fragment physical memory by loading OS modules

	auto rps

	// allocate pageframe DB

	pages@ 32 * rps!

	rps@ "pageframe db is %d bytes" Printf

	rps@ 4095 + 12 >> PFDBBASE 12 >> 0 MemAllocUpper ok! astart!

	if (ok@)
		"couldn't allocate pageframe db\n" LoaderPanic
	end

	astart@ 12 << MemPageFrameDB!

	MemPageFrameDB@ " at 0x%08x\n" Printf

	// allocate kernel heap

	auto heapmax
	"HEAPMAX" ArgsValue heapmax!

	if (heapmax@)
		heapmax@ atoi 1024 * heapmax!
	end else
		HEAPMAXDEFAULT heapmax!
	end

	auto heapmin
	"HEAPMIN" ArgsValue heapmin!

	if (heapmin@)
		heapmin@ atoi 1024 * heapmin!
	end else
		HEAPMINDEFAULT heapmin!
	end

	auto heapshf
	"HEAPSHF" ArgsValue heapshf!

	if (heapshf@)
		heapshf@ atoi heapshf!
	end else
		HEAPSHFDEFAULT heapshf!
	end

	pages@ heapshf@ >> 12 << rps!

	if (rps@ heapmin@ <)
		heapmin@ rps!
	end elseif (rps@ heapmax@ >)
		heapmax@ rps!
	end

	// round down to nearest power of two
	// I dont know why this works. I found it on a website somewhere

	rps@ 1 >> rps |=
	rps@ 2 >> rps |=
	rps@ 4 >> rps |=
	rps@ 8 >> rps |=
	rps@ 16 >> rps |=
	rps@ 1 >> rps -=

	rps@ 4095 + 12 >> rps!

	rps@ 12 << "heap is %d bytes" Printf

	rps@ HEAPBASE 12 >> 0 MemAllocUpper ok! astart!

	if (ok@)
		"\ncouldn't allocate kernel heap\n" LoaderPanic
	end

	astart@ 12 << MemHeap!
	rps@ 12 << MemHeapSize!

	MemHeap@ " at 0x%08x\n" Printf
end

fn HexDump { addr len -- }
	auto i
	0 i!

	while (len@)
		if (i@ 4 % 0 == i@ &&)
			'\n' Putc
		end

		addr@ @ "%9x " Printf

		1 i +=
		4 addr +=
		4 len -=
	end

	'\n' Putc
end

fn MemSetStatus { with pages start -- }
	auto max
	pages@ start@ + max!

	auto bmp
	MemBitmap start@ 32 / 4 * + bmp!

	auto word
	bmp@@ word!

	auto q
	start@ q!

	while (start@ max@ <)
		if (with@)
			word@ start@ 31 & bitset word!
		end else
			word@ start@ 31 & bitclear word!
		end

		1 start +=

		if (start@ 31 & ~~)
			word@ bmp@!

			4 bmp +=

			bmp@@ word!
		end
	end

	word@ bmp@!
end

const PTE_V  1
const PTE_W  2
const PTE_K  4
const PTE_NC 8
const PTE_G  16

const PTE_KPAGE (PTE_V PTE_W | PTE_K |)

fn MemMapPage { phys virt nc -- ok }
	0 ok!

	auto pdi
	virt@ 22 >> 2 << MemPageDirectory@ + pdi!

	auto pt
	pdi@@ 5 >> 12 << pt!

	if (pt@ 0 ==)
		1 0 MemAlloc ok! pt!

		if (ok@)
			return
		end

		12 pt <<=

		pt@ 4096 0 memset

		pt@ 12 >> 5 << pdi@!
	end

	virt@ 12 >> 1023 & 2 << pt@ + pdi!

	if (pdi@@ PTE_V &)
		virt@ 12 >> "MemMapPage: vpn %x is already mapped!\n" LoaderPanic
	end

	auto flags
	PTE_KPAGE flags!

	if (virt@ KERNELSPACE &)
		PTE_G flags |=
	end

	if (nc@)
		PTE_NC flags |=
	end

	phys@ 12 >> 5 << flags@ | pdi@!
end

const PAGEMAX 1048576

fn MemFindEmptyRow { length start must -- ok ava }
	if (start@ KERNELSPACE <)
		"MemFindEmptyRow: start was below kernelspace\n" LoaderPanic
	end

	auto i
	start@ 12 >> i!

	auto pd
	MemPageDirectory@ start@ 22 >> 2 << + pd!

	auto pt
	pd@@ 5 >> 12 << pt!

	auto max
	PAGEMAX max!

	auto r
	0 r!

	auto row
	0 row!

	auto cv
	start@ cv!
	start@ ava!

	auto rmnd
	i@ 1023 & rmnd!

	if (rmnd@)
		if (pt@ 0 ==)
			1024 rmnd@ - row!
			1024 rmnd@ - i +=
			0x400000 rmnd@ 12 << - cv +=
		end else
			rmnd@ 2 << pt +=
		end

		4 pd +=
	end

	while (1)
		if (row@ length@ >=)
			0 ok!
			return
		end

		if (i@ max@ >=)
			if (start@ KERNELSPACE ==)
				(* already searched the whole thing *)
				break
			end

			if (r@)
				break
			end

			1 r!
			KERNELSPACE 12 >> i!
			0 row!
			start@ 12 >> max!
			KERNELSPACE ava!
			KERNELSPACE cv!
			MemPageDirectory@ KERNELSPACE 22 >> 2 << + pd!
		end

		if (i@ 1023 & 0 ==)
			pd@@ 5 >> 12 << pt!

			4 pd +=
		end

		if (pt@ 0 ==)
			1024 row +=
			1024 i +=
			0x400000 cv +=

			continue
		end

		if (pt@@)
			if (must@)
				break
			end

			0 row!
			cv@ 0x1000 + ava!
		end else
			1 row +=
		end
		
		1 i +=
		4 pt +=
		0x1000 cv +=
	end

	ERR ok!
end

fn MemMapIORange { pages phys -- vaddr ok }
	pages@ KERNELSTRUCTURES 0 MemFindEmptyRow vaddr! ok!

	if (ok@)
		return
	end

	auto i
	0 i!

	auto vptr
	vaddr@ vptr!

	while (i@ pages@ <)
		phys@ vptr@ 1 MemMapPage ok!

		if (ok@)
			return
		end

		4096 vptr +=
		4096 phys +=
		1 i +=
	end
end

fn MemAllocUpper { pages vstart must -- astart ok }
	pages@ vstart@ 12 << must@ MemFindEmptyRow astart! ok!

	if (ok@)
		-1 astart!

		return
	end

	// astart@ ok@ "ok=%08x astart=%08x\n" Printf

	auto pptr

	auto vptr
	astart@ vptr!

	auto i
	0 i!

	while (i@ pages@ <)
		1 0 MemAlloc ok! pptr!

		if (ok@)
			// XXX doesn't free everything it just allocated...
			return
		end

		pptr@ 12 << vptr@ 0 MemMapPage ok!

		if (ok@)
			return
		end

		4096 vptr +=
		1 i +=
	end 

	12 astart >>=

	0 ok!
end

fn MemFree { pages pstart -- }
	pages@ MemAllocated -=

	0 pages@ pstart@ MemSetStatus
end

var MemLastAlloc 0

fn MemAllocSinglePage { pstart -- astart ok }
	if (pstart@ 0 ==)
		MemLastAlloc@ pstart!
	end

	auto chend
	MemPages@ chend!

	if (pstart@ chend@ >=)
		0 pstart!
	end

	auto i
	pstart@ i!

	auto bmp
	MemBitmap i@ 32 / 4 * + bmp!

	auto mode
	0 mode!

	while (bmp@@ 0xFFFFFFFF ==)
		4 bmp +=
		32 i +=

		if (i@ chend@ >=)
			if (mode@)
				-1 ok!
				return
			end else
				0 i!
				1 mode!
				pstart@ chend!
				MemBitmap bmp!
			end
		end
	end

	auto word
	bmp@@ word!

	auto j
	0 j!

	while (j@ 32 <)
		if (word@ j@ bitget ~~)
			word@ j@ bitset bmp@!

			i@ 31 ~ & j@ | astart!
			astart@ 1 + MemLastAlloc!

			0 ok!
			return
		end

		1 i +=
		1 j +=
	end

	"MemAllocSinglePage\n" LoaderPanic
end

fn MemAlloc { pages pstart -- astart ok }
	-1 ok!

	if (pages@ 0 ==)
		"tried to allocate 0 pages\n" LoaderPanic
	end

	if (pages@ 1 ==)
		pstart@ MemAllocSinglePage ok! astart!
		return
	end

	auto chend
	MemPages@ chend!

	auto i
	pstart@ i!

	auto bmp
	MemBitmap i@ 32 / 4 * + bmp!

	auto run
	0 run!

	auto mode
	0 mode!

	while (1)
		if (i@ chend@ >=)
			if (mode@)
				-1 ok!
				return
			end else
				0 i!
				1 mode!
				0 run!
				pstart@ chend!
				MemBitmap bmp!
			end
		end

		if (bmp@@ i@ 31 & bitget)
			0 run!
		end else
			if (run@ 0 ==)
				i@ astart!
			end

			1 run +=
		end

		if (run@ pages@ >=)
			1 pages@ astart@ MemSetStatus

			pages@ MemAllocated +=

			0 ok!
			return
		end 

		1 i +=

		if (i@ 31 & ~~)
			4 bmp +=

			if (bmp@@ 0xFFFFFFFF ==)
				32 i +=
				0 run!
				4 bmp +=
			end elseif (bmp@@ 0x00000000 ==)
				if (run@ 0 ==)
					i@ astart!
				end

				32 i +=
				32 run +=
				4 bmp +=
			end
		end
	end
end

fn MemDumpBitmap { -- }
	auto bmp
	MemBitmap bmp!

	auto i
	0 i!

	auto ende
	MemPages@ 1024 min ende!

	while (i@ ende@ <)
		auto bit
		i@ 7 & bit!

		if (bit@ 0 ==)
			'|' Putc
		end

		bmp@ i@ 8 / + gb bit@ bitget bit!

		if (bit@)
			'x' Putc
		end else
			' ' Putc
		end

		1 i +=
	end
end

const RS_MMU 4

asm "

MemExit:
.global MemExit
	mtcr rs, zero
	ret

MemEnablePaging:
.global MemEnablePaging
	subi t0, zero, 1
	ftlb t0, t0

	mtcr asid, zero

	la   t0, MemPageDirectory
	mov  t0, long [t0]
	mtcr pgtb, t0
	mfcr t0, rs
	ori  t0, t0, RS_MMU
	mtcr rs, t0
	ret

"
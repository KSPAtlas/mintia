#include "<df>/dragonfruit.h"
#include "<inc>/HALLog.h"

#include "<inc>/HALCPU.h"
#include "<inc>/HALRTC.h"

#include "<inc>/KeCrash.h"

#include "<inc>/KeMemAlloc.h"

#include "<inc>/KeDPC.h"
#include "<inc>/KeTime.h"
#include "<inc>/KeTimer.h"

#include "<inc>/KeProcess.h"

#include "<inc>/KeIPL.h"

#include "<ll>/OSDLL/OSStatus.h"

table KeThreadPriorityQueueHeads[PRIORITIES]
public KeThreadPriorityQueueHeads

table KeThreadPriorityQueueTails[PRIORITIES]

var KeThreadCurrent 0
public KeThreadCurrent

var KeThreadNext 0
public KeThreadNext

var KeThreadNextReason 0
public KeThreadNextReason

externptr HALThreadCurrentStackTop

const THREADDEFAULTQUANTUMUNITS (THREADDEFAULTQUANTUM HALRTCINTERVAL / QUANTUMUNITSPERTICK *)

externptr KeThreadTimerWake

// 'context1' and 'context2' are parameters passed to the start function

fn KeThreadInitialize { context1 context2 startfunc process name thread -- ok }
	thread@ KeThread_Name + name@ KETHREADNAMELEN 1 - strncpy

	THREADSTATUS_INITIALIZED thread@ KeThread_Status + !

	THREADDEFAULTQUANTUMUNITS thread@ KeThread_BaseQuantum + !
	THREADDEFAULTQUANTUMUNITS thread@ KeThread_Quantum + !

	process@ thread@ KeThread_Process + !

	process@ KeProcess_BasePriority + @ thread@ KeThread_Priority + !
	process@ KeProcess_BasePriority + @ thread@ KeThread_BasePriority + !

	auto kstack
	KeMemPageAlloc kstack! drop

	if (kstack@ iserr)
		kstack@ ok!
		return
	end

	12 kstack <<=

	context1@ context2@ startfunc@ kstack@ 4096 + HALCPUContextInit thread@ KeThread_Context + !

	kstack@ thread@ KeThread_KernelStackBottom + !
	kstack@ 4096 + thread@ KeThread_KernelStackTop + !

	// add to the process's thread list

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto h
	process@ KeProcess_ThreadListHead + @ h!

	if (h@)
		thread@ h@ KeThread_ProcessPrev + !
		h@ thread@ KeThread_ProcessNext + !
	end

	thread@ process@ KeProcess_ThreadListHead + !

	1 process@ KeProcess_ThreadCount + +=

	ipl@ KeIPLLower

	0 thread@ KeThread_QueueNext + !
	0 thread@ KeThread_QueuePrev + !

	0 thread@ KeThread_APCUserListHead + !
	0 thread@ KeThread_APCUserListTail + !

	0 thread@ KeThread_APCKernelListHead + !
	0 thread@ KeThread_APCKernelListTail + !

	0 thread@ KeThread_Enqueued + !

	0 thread@ KeThread_WaitStatus + !
	0 thread@ KeThread_WaitMode + !
	0 thread@ KeThread_WaitIPL + !

	0 thread@ KeThread_KernelAPCDisableCount + !

	1 thread@ KeThread_APCQueueable + !

	KERNELMODE thread@ KeThread_PreviousMode + !

	pointerof KeThreadTimerWake thread@ KeThread_WakeTimer + KeTimerInitialize ok!
end

fn KeThreadWorkerInitialize { context1 context2 startfunc name thread -- ok }
	context1@ context2@ startfunc@ KeProcessKernelProcess name@ thread@ KeThreadInitialize ok!
end

fn KeThreadEnqueue { front thread -- }
	// add thread to the tail of the proper ready queue for its priority level

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (thread@ KeThread_Enqueued + @)
		"KeThreadEnqueue: attempt to enqueue an enqueued thread\n" KeCrash
	end

	1 thread@ KeThread_Enqueued + !

	auto pri
	thread@ KeThread_Priority + @ pri!

	auto t

	if (front@)
		[pri@]KeThreadPriorityQueueHeads@ t!

		if (t@ ~~)
			thread@ [pri@]KeThreadPriorityQueueTails!

			0 thread@ KeThread_QueueNext + !
			0 thread@ KeThread_QueuePrev + !
		end else
			t@ thread@ KeThread_QueueNext + !
			thread@ t@ KeThread_QueuePrev + !

			0 thread@ KeThread_QueuePrev + !
		end

		thread@ [pri@]KeThreadPriorityQueueHeads!
	end else
		[pri@]KeThreadPriorityQueueTails@ t!

		if (t@ ~~)
			thread@ [pri@]KeThreadPriorityQueueHeads!

			0 thread@ KeThread_QueueNext + !
			0 thread@ KeThread_QueuePrev + !
		end else
			thread@ t@ KeThread_QueueNext + !
			t@ thread@ KeThread_QueuePrev + !

			0 thread@ KeThread_QueueNext + !
		end

		thread@ [pri@]KeThreadPriorityQueueTails!
	end

	ipl@ KeIPLLower
end

fn KeThreadDequeue { thread -- }
	// remove thread from the proper ready queue for its priority level

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (thread@ KeThread_Enqueued + @ ~~)
		"KeThreadDequeue: attempt to dequeue a dequeued thread\n" KeCrash
	end

	0 thread@ KeThread_Enqueued + !

	auto pri
	thread@ KeThread_Priority + @ pri!

	auto n
	thread@ KeThread_QueueNext + @ n!

	if (n@)
		thread@ KeThread_QueuePrev + @ n@ KeThread_QueuePrev + !
	end else // no next means we were the tail
		thread@ KeThread_QueuePrev + @ [pri@]KeThreadPriorityQueueTails!
	end

	auto p
	thread@ KeThread_QueuePrev + @ p!

	if (p@)
		thread@ KeThread_QueueNext + @ p@ KeThread_QueueNext + !
	end else // no prev means we were the head
		thread@ KeThread_QueueNext + @ [pri@]KeThreadPriorityQueueHeads!
	end

	0 thread@ KeThread_QueueNext + !
	0 thread@ KeThread_QueuePrev + !

	ipl@ KeIPLLower
end

// implements the thread transition state machine

fn KeThreadTransition1 { status thread front -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto oldstatus
	thread@ KeThread_Status + @ oldstatus!

	if (status@ oldstatus@ ==)
		// no change, return

		ipl@ KeIPLLower

		return
	end

	if (oldstatus@ THREADSTATUS_READY ==)
		// no longer ready, dequeue

		thread@ KeThreadDequeue
	end elseif (status@ THREADSTATUS_READY ==)
		// now ready, enqueue

		front@ thread@ KeThreadEnqueue

		auto current
		KeThreadCurrent@ current!

		if (current@ ~~)
			"KeThreadTransition: no current thread\n" KeCrash
		end

		if (thread@ KeThread_Priority + @ current@ KeThread_Priority + @ >)
			// this thread's priority is greater than the current thread's

			thread@ THREADYIELD_PREEMPTED KeThreadNextSelect
		end
	end

	status@ thread@ KeThread_Status + !

	ipl@ KeIPLLower
end

fn KeThreadTransition { status thread -- }
	status@ thread@ QUEUEBACK KeThreadTransition1
end

fn KeThreadReady { front thread -- }
	THREADSTATUS_READY thread@ front@ KeThreadTransition1
end

fn KeThreadQuantumIncrement { inc thread -- qt }
	auto ipl
	IPLCLOCK KeIPLRaise ipl!

	thread@ KeThread_Quantum + @ qt!

	inc@ qt +=

	qt@ thread@ KeThread_Quantum + !

	ipl@ KeIPLLower
end

fn KeThreadQuantumDecrement { dec thread -- qt }
	auto ipl
	IPLCLOCK KeIPLRaise ipl!

	thread@ KeThread_Quantum + @ qt!

	if (qt@ dec@ <=)
		0 qt!
	end else
		dec@ qt -=
	end

	qt@ thread@ KeThread_Quantum + !

	ipl@ KeIPLLower
end

fn KeThreadQuantumEnd { -- }
	auto current
	KeThreadCurrent@ current!

	if (current@ KeThread_Status + @ THREADSTATUS_RUNNING ~=)
		"KeThreadQuantumEnd: current thread isn't RUNNING\n" KeCrash
	end

	if (current@ KeThread_Enqueued + @)
		"KeThreadQuantumEnd: current thread is RUNNING yet enqueued\n" KeCrash
	end

	auto pri
	current@ KeThread_Priority + @ pri!

	if (pri@ PRIORITY_IDLE >)
		if (pri@ PRIORITY_LOWREALTIME <)
			auto newpri
			pri@ 1 - newpri!

			if (newpri@ current@ KeThread_BasePriority + @ >)
				newpri@ current@ KeThread_Priority + !
			end
		end
	end

	KeThreadNextPick THREADYIELD_QUANTUMEND KeThreadNextSelect
end

fn (DPCFunction) KeThreadQuantumDPCFunction { context1 context2 -- }
	KeThreadQuantumEnd
end

fn KeThreadNextPick { -- thread }
	auto i
	PRIORITIES i!

	while (i@)
		1 i -=

		auto h
		[i@]KeThreadPriorityQueueHeads@ h!

		while (h@)
			if (h@ KeThread_Status + @ THREADSTATUS_READY ==)
				h@ thread!

				return
			end else
				"KeThreadNextPick: thread on ready queue but not READY\n" KeCrash
			end

			h@ KeThread_QueueNext + @ h!
		end
	end

	// must be the idle thread, just continue
	KeThreadCurrent@ thread!
end

var InitialContext 0

// should be called with interrupts disabled at IPLDPC.
// current thread should have been transitioned to the proper state beforehand

// XXX maybe this function should be rolled into KeThreadNextSwitch?

fn KeThreadSwitch { thread -- }
	if (KeIPLCurrentGet IPLDPC ~=)
		"KeThreadSwitch: ipl ~= IPLDPC\n" KeCrash
	end

	auto current
	KeThreadCurrent@ current!

	THREADSTATUS_RUNNING thread@ KeThreadTransition

	thread@ KeThread_KernelStackTop + @ HALThreadCurrentStackTop!

	if (thread@ current@ ==)
		return
	end

	auto old

	if (current@)
		current@ KeThread_Context + old!
	end else
		InitialContext old!
	end

	thread@ KeThreadCurrent!

	old@ thread@ KeThread_Context + @ HALCPUContextSwitch

	auto qtm
	current@ KeThread_Quantum + @ qtm!

	if (qtm@ ~~)
		// no more quantum, do a quantum end

		KeThreadQuantumEnd
	end
end

fn KeThreadPrioritySet { priority thread -- }
	if (KeIPLCurrentGet IPLDPC ~=)
		"KeThreadPrioritySet: ipl != IPLDPC\n" KeCrash
	end

	auto pri
	thread@ KeThread_Priority + @ pri!

	if (pri@ priority@ ==)
		return
	end

	if (priority@ pri@ >)
		// the priority has been raised. if the thread is running or waiting, do nothing.
		// however, if the thread is in a ready queue, it must be requeued.
		// if this action raises its priority above that of the current thread, ask the
		// scheduler to run.

		if (thread@ KeThread_Status + @ THREADSTATUS_READY ==)
			thread@ KeThreadDequeue

			priority@ thread@ KeThread_Priority + !

			QUEUEBACK thread@ KeThreadEnqueue

			if (priority@ KeThreadCurrent@ KeThread_Priority + @ >)
				thread@ THREADYIELD_PREEMPTED KeThreadNextSelect
			end
		end else
			if (thread@ KeThread_Enqueued + @)
				"KeThreadPrioritySet: thread was enqueued despite not being READY\n" KeCrash
			end

			priority@ thread@ KeThread_Priority + !
		end
	end else
		// the priority has been lowered. if the thread is in a ready queue, it must be requeued.
		// if the thread is currently running, see if there is now a higher priority thread that can run.
		// if so, ask the scheduler to run.

		auto status
		thread@ KeThread_Status + @ status!

		if (status@ THREADSTATUS_READY ==)
			thread@ KeThreadDequeue

			priority@ thread@ KeThread_Priority + !

			QUEUEBACK thread@ KeThreadEnqueue
		end elseif (status@ THREADSTATUS_RUNNING ==)
			if (thread@ KeThreadCurrent@ ~=)
				"KeThreadPrioritySet: thread is RUNNING, but is not the current thread\n" KeCrash
			end

			priority@ thread@ KeThread_Priority + !

			auto i
			PRIORITIES 1 - i!

			while (i@ priority@ >)
				auto qh
				[i@]KeThreadPriorityQueueHeads@ qh!

				if (qh@)
					qh@ THREADYIELD_PREEMPTED KeThreadNextSelect
				end

				1 i -=
			end
		end
	end
end

fn KeThreadNextSelect { next reason -- }
	auto onext
	KeThreadNext@ onext!

	if (reason@ THREADYIELD_QUANTUMEND ==)
		if (KeThreadCurrent@ KeThread_Priority + @ next@ KeThread_Priority + @ >)
			return
		end
	end

	if (onext@)
		if (next@ KeThread_Priority + @ onext@ KeThread_Priority + @ >=)
			next@ KeThreadNext!
			reason@ KeThreadNextReason!
		end
	end else
		next@ KeThreadNext!
		reason@ KeThreadNextReason!
	end

	if (KeThreadNext@ KeThreadCurrent@ ==)
		// no reschedule required

		0 KeThreadNext!
	end
end

fn KeThreadPriorityBoost { boost thread -- }
	auto pri
	thread@ KeThread_Priority + @ pri!

	if (pri@ PRIORITY_LOWREALTIME <)
		auto newpri
		thread@ KeThread_BasePriority + @ boost@ + newpri!

		if (newpri@ PRIORITY_HIGHUSER >)
			PRIORITY_HIGHUSER newpri!
		end

		if (newpri@ pri@ >)
			newpri@ thread@ KeThreadPrioritySet
		end
	end
end

fn KeThreadNextSwitch { -- }
	while (KeThreadNext@)
		auto next
		KeThreadNext@ next!

		0 KeThreadNext!

		auto current
		KeThreadCurrent@ current!

		auto cause
		KeThreadNextReason@ cause!

		0 KeThreadNextReason!

		if (cause@ THREADYIELD_QUANTUMEND ==)
			// the quantum ended, place it at the back

			current@ KeThread_BaseQuantum + @ current@ KeThread_Quantum + !

			QUEUEBACK current@ KeThreadReady
		end elseif (cause@ THREADYIELD_PREEMPTED ==)
			// it was preempted, place it at the front

			1 current@ KeThreadQuantumDecrement drop

			QUEUEFRONT current@ KeThreadReady
		end else
			cause@ "KeThreadNextSwitch: weird cause (0x%x)\n" KeCrash
		end

		// if a reschedule was deferred, do it here

		// this is done here instead of in a DPC to ensure that the entire
		// DPC queue is processed before the thread switch occurs.

		next@ KeThreadSwitch
	end
end

// for when you want to yield NOW and in a particular state
// this function is used e.g. when waiting on an object

// only called in normal thread context at IPLDPC

fn KeThreadYield { yieldstatus -- }
	if (KeDPCActive@)
		"KeThreadYieldNow: DPC active\n" KeCrash
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto current
	KeThreadCurrent@ current!

	yieldstatus@ current@ KeThreadTransition

	0 KeThreadNextReason!
	0 KeThreadNext!

	KeThreadNextPick KeThreadSwitch

	ipl@ KeIPLLower
end
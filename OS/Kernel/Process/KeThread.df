#include "<df>/dragonfruit.h"
#include "<inc>/HALLog.h"

#include "<inc>/HALCPU.h"

#include "<inc>/KeCrash.h"

#include "<inc>/KeMemAlloc.h"
#include "<inc>/KeProcess.h"

#include "<inc>/KeIPL.h"

#include "<inc>/KeTimer.h"

#include "<ll>/RTL/RTLErrors.h"

table KeThreadPriorityQueueHeads[PRIORITIES]
public KeThreadPriorityQueueHeads

table KeThreadPriorityQueueTails[PRIORITIES]

var KeThreadCurrent 0
public KeThreadCurrent

var KeThreadNext 0
public KeThreadNext

var KeThreadNextReason 0
public KeThreadNextReason

// 'context1' and 'context2' are parameters passed to the start function

fn KeThreadInitialize { context1 context2 startfunc process name thread -- ok }
	thread@ KeThread_Name + name@ KETHREADNAMELEN 1 - strncpy

	THREADSTATUS_INITIALIZED thread@ KeThread_Status + !

	THREADDEFAULTQUANTUM thread@ KeThread_BaseQuantum + !
	THREADDEFAULTQUANTUM thread@ KeThread_Quantum + !

	process@ thread@ KeThread_Process + !

	process@ KeProcess_BasePriority + @ thread@ KeThread_Priority + !
	process@ KeProcess_BasePriority + @ thread@ KeThread_BasePriority + !

	auto kstack
	KeMemPageAlloc kstack! drop

	if (kstack@ iserr)
		kstack@ ok!
		return
	end

	12 kstack <<=

	context1@ context2@ startfunc@ kstack@ 4096 + HALCPUContextInit thread@ KeThread_Context + !

	kstack@ thread@ KeThread_KernelStackBottom + !
	kstack@ 4096 + thread@ KeThread_KernelStackTop + !

	// add to the process's thread list

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto h
	process@ KeProcess_ThreadListHead + @ h!

	if (h@)
		thread@ h@ KeThread_ProcessPrev + !
		h@ thread@ KeThread_ProcessNext + !
	end

	thread@ process@ KeProcess_ThreadListHead + !

	1 process@ KeProcess_ThreadCount + +=

	ipl@ KeIPLLower

	0 thread@ KeThread_QueueNext + !
	0 thread@ KeThread_QueuePrev + !

	0 thread@ KeThread_Enqueued + !

	0 ok!
end

fn KeThreadWorkerInitialize { context1 context2 startfunc name thread -- ok }
	context1@ context2@ startfunc@ KeProcessKernelProcess name@ thread@ KeThreadInitialize ok!
end

fn KeThreadEnqueue { front thread -- }
	// add thread to the tail of the proper ready queue for its priority level

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (thread@ KeThread_Enqueued + @)
		"KeThreadEnqueue: attempt to enqueue an enqueued thread\n" KeCrash
	end

	1 thread@ KeThread_Enqueued + !

	auto pri
	thread@ KeThread_Priority + @ pri!

	auto t

	if (front@)
		[pri@]KeThreadPriorityQueueHeads@ t!

		if (t@ ~~)
			thread@ [pri@]KeThreadPriorityQueueTails!

			0 thread@ KeThread_QueueNext + !
			0 thread@ KeThread_QueuePrev + !
		end else
			t@ thread@ KeThread_QueueNext + !
			thread@ t@ KeThread_QueuePrev + !

			0 thread@ KeThread_QueuePrev + !
		end

		thread@ [pri@]KeThreadPriorityQueueHeads!
	end else
		[pri@]KeThreadPriorityQueueTails@ t!

		if (t@ ~~)
			thread@ [pri@]KeThreadPriorityQueueHeads!

			0 thread@ KeThread_QueueNext + !
			0 thread@ KeThread_QueuePrev + !
		end else
			thread@ t@ KeThread_QueueNext + !
			t@ thread@ KeThread_QueuePrev + !

			0 thread@ KeThread_QueueNext + !
		end

		thread@ [pri@]KeThreadPriorityQueueTails!
	end

	ipl@ KeIPLLower
end

fn KeThreadDequeue { thread -- }
	// remove thread from the proper ready queue for its priority level

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (thread@ KeThread_Enqueued + @ ~~)
		"KeThreadDequeue: attempt to dequeue a dequeued thread\n" KeCrash
	end

	0 thread@ KeThread_Enqueued + !

	auto pri
	thread@ KeThread_Priority + @ pri!

	auto n
	thread@ KeThread_QueueNext + @ n!

	if (n@)
		thread@ KeThread_QueuePrev + @ n@ KeThread_QueuePrev + !
	end else // no next means we were the tail
		thread@ KeThread_QueuePrev + @ [pri@]KeThreadPriorityQueueTails!
	end

	auto p
	thread@ KeThread_QueuePrev + @ p!

	if (p@)
		thread@ KeThread_QueueNext + @ p@ KeThread_QueueNext + !
	end else // no prev means we were the head
		thread@ KeThread_QueueNext + @ [pri@]KeThreadPriorityQueueHeads!
	end

	0 thread@ KeThread_QueueNext + !
	0 thread@ KeThread_QueuePrev + !

	ipl@ KeIPLLower
end

// implements the thread transition state machine

fn KeThreadTransition1 { status thread front -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto oldstatus
	thread@ KeThread_Status + @ oldstatus!

	if (status@ oldstatus@ ==)
		// no change, return

		ipl@ KeIPLLower

		return
	end

	if (oldstatus@ THREADSTATUS_READY ==)
		// no longer ready, dequeue

		thread@ KeThreadDequeue
	end elseif (status@ THREADSTATUS_READY ==)
		// now ready, enqueue

		front@ thread@ KeThreadEnqueue

		auto current
		KeThreadCurrent@ current!

		if (current@)
			if (thread@ KeThread_Priority + @ current@ KeThread_Priority + @ >)
				// this thread's priority is greater than the current thread's

				thread@ THREADYIELD_PREEMPTED KeThreadNextSelect
			end
		end
	end

	status@ thread@ KeThread_Status + !

	ipl@ KeIPLLower
end

fn KeThreadTransition { status thread -- }
	status@ thread@ QUEUEBACK KeThreadTransition1
end

fn KeThreadReady { front thread -- }
	THREADSTATUS_READY thread@ front@ KeThreadTransition1
end

fn KeThreadQuantumEnd { -- }
	auto current
	KeThreadCurrent@ current!

	if (current@ KeThread_Status + @ THREADSTATUS_READY ==)
		"KeThreadQuantumEnd: current thread is READY\n" KeCrash
	end

	if (current@ KeThread_Enqueued + @)
		"KeThreadQuantumEnd: current thread is RUNNING yet enqueued\n" KeCrash
	end

	auto pri
	current@ KeThread_Priority + @ pri!

	if (pri@ PRIORITY_LOWREALTIME <)
		auto newpri
		pri@ 1 - newpri!

		if (newpri@ current@ KeThread_BasePriority + @ <)
			current@ KeThread_BasePriority + @ newpri!
		end

		newpri@ current@ KeThread_Priority + !
	end

	KeThreadNextPick THREADYIELD_QUANTUMEND KeThreadNextSelect
end

fn (DPCFunction) KeThreadQuantumDPCFunction { context1 context2 -- }
	KeThreadQuantumEnd
end

fn KeThreadNextPick { -- thread }
	auto i
	PRIORITIES i!

	while (i@)
		1 i -=

		auto h
		[i@]KeThreadPriorityQueueHeads@ h!

		while (h@)
			if (h@ KeThread_Status + @ THREADSTATUS_READY ==)
				h@ thread!

				return
			end else
				"KeThreadNextPick: thread on ready queue but not READY\n" KeCrash
			end

			h@ KeThread_QueueNext + @ h!
		end
	end

	"KeThreadNextPick: no threads?\n" KeCrash
end

var InitialContext 0

// should be called with interrupts disabled at IPLDPC.
// current thread should have been transitioned to the proper state beforehand

fn KeThreadSwitch { thread -- }
	if (KeIPLCurrentGet IPLDPC ~=)
		"KeThreadSwitch: ipl ~= IPLDPC\n" KeCrash
	end

	auto current
	KeThreadCurrent@ current!

	auto qt
	KeThreadQuantumTimer qt!

	if (qt@ KeTimer_Enqueued + @)
		qt@ KeTimerDequeue drop
	end

	auto quantum
	thread@ KeThread_Quantum + @ quantum!

	if (quantum@)
		THREADYIELD_QUANTUMEND 0 quantum@ qt@ KeTimerEnqueue drop
	end

	THREADSTATUS_RUNNING thread@ KeThreadTransition

	if (thread@ current@ ==)
		return
	end

	auto old

	if (current@)
		current@ KeThread_Context + old!
	end else
		InitialContext old!
	end

	thread@ KeThreadCurrent!

	if (quantum@ ~~)
		// there's no quantum anymore, this thread has been preempted a lot.
		// do a quantum end.

		KeThreadQuantumEnd
	end

	old@ thread@ KeThread_Context + @ HALCPUContextSwitch
end

fn KeThreadPrioritySet { priority thread -- }
	if (KeIPLCurrentGet IPLDPC ~=)
		"KeThreadPrioritySet: ipl != IPLDPC\n" KeCrash
	end

	auto pri
	thread@ KeThread_Priority + @ pri!

	if (pri@ priority@ ==)
		return
	end

	if (priority@ pri@ >)
		// the priority has been raised. if the thread is running or waiting, do nothing.
		// however, if the thread is in a ready queue, it must be requeued.
		// if this action raises its priority above that of the current thread, ask the
		// scheduler to run.

		if (thread@ KeThread_Status + @ THREADSTATUS_READY ==)
			thread@ KeThreadDequeue

			priority@ thread@ KeThread_Priority + !

			QUEUEBACK thread@ KeThreadEnqueue

			if (priority@ KeThreadCurrent@ KeThread_Priority + @ >)
				thread@ THREADYIELD_PREEMPTED KeThreadNextSelect
			end
		end else
			if (thread@ KeThread_Enqueued + @)
				"KeThreadPrioritySet: thread was enqueued despite not being READY\n" KeCrash
			end

			priority@ thread@ KeThread_Priority + !
		end
	end else
		// the priority has been lowered. if the thread is in a ready queue, it must be requeued.
		// if the thread is currently running, see if there is now a higher priority thread that can run.
		// if so, ask the scheduler to run.

		auto status
		thread@ KeThread_Status + @ status!

		if (status@ THREADSTATUS_READY ==)
			thread@ KeThreadDequeue

			priority@ thread@ KeThread_Priority + !

			QUEUEBACK thread@ KeThreadEnqueue
		end elseif (status@ THREADSTATUS_RUNNING ==)
			if (thread@ KeThreadCurrent@ ~=)
				"KeThreadPrioritySet: thread is RUNNING, but is not the current thread\n" KeCrash
			end

			priority@ thread@ KeThread_Priority + !

			auto i
			PRIORITIES 1 - i!

			while (i@ priority@ >)
				auto qh
				[i@]KeThreadPriorityQueueHeads@ qh!

				if (qh@)
					qh@ THREADYIELD_PREEMPTED KeThreadNextSelect
				end

				1 i -=
			end
		end
	end
end

fn KeThreadNextSelect { next reason -- }
	auto onext
	KeThreadNext@ onext!

	if (onext@)
		if (next@ KeThread_Priority + @ onext@ KeThread_Priority + @ >=)
			next@ KeThreadNext!
			reason@ KeThreadNextReason!
		end
	end else
		next@ KeThreadNext!
		reason@ KeThreadNextReason!
	end

	if (KeThreadNext@ KeThreadCurrent@ ==)
		0 KeThreadNext!
	end
end

fn KeThreadPriorityBoost { boost thread -- }
	auto pri
	thread@ KeThread_Priority + @ pri!

	if (pri@ PRIORITY_LOWREALTIME <)
		auto newpri
		thread@ KeThread_BasePriority + @ boost@ + newpri!

		if (newpri@ PRIORITY_HIGHUSER >)
			PRIORITY_HIGHUSER newpri!
		end

		if (newpri@ pri@ >)
			newpri@ thread@ KeThreadPrioritySet
		end
	end
end

fn KeThreadNextSwitch { -- }
	while (KeThreadNext@)
		auto next
		KeThreadNext@ next!

		0 KeThreadNext!

		auto current
		KeThreadCurrent@ current!

		auto cause
		KeThreadNextReason@ cause!

		0 KeThreadNextReason!

		if (cause@ THREADYIELD_QUANTUMEND ==)
			// the quantum ended, place it at the back

			current@ KeThread_BaseQuantum + @ current@ KeThread_Quantum + !

			QUEUEBACK current@ KeThreadReady
		end elseif (cause@ THREADYIELD_PREEMPTED ==)
			// it was preempted, place it at the front

			if (current@ KeThread_Quantum + @)
				1 current@ KeThread_Quantum + -=
			end

			QUEUEFRONT current@ KeThreadReady
		end

		// if a reschedule was deferred, do it here

		// this is done here instead of in a DPC to ensure that the entire
		// DPC queue is processed before the thread switch occurs.

		next@ KeThreadSwitch
	end
end

// for when you want to yield NOW and in a particular state
// this function is used e.g. when waiting on an object

// only called in normal thread context at IPLDPC

fn KeThreadYield { yieldstatus -- }
	if (KeDPCActive@)
		"KeThreadYieldNow: DPC active\n" KeCrash
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto current
	KeThreadCurrent@ current!

	yieldstatus@ current@ KeThreadTransition

	KeThreadNextPick 0 KeThreadNextSelect

	ipl@ KeIPLLower
end
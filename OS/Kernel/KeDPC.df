#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/KeIPL.h"
#include "<inc>/KeCrash.h"
#include "<inc>/KeDPC.h"

#include "<inc>/HALCPU.h"

var KeDPCListHead 0
public KeDPCListHead

var KeDPCListTail 0
public KeDPCListTail

fn KeDPCInitialize { function dpc -- ok }
	function@ dpc@ DPC_Function + !
	0 dpc@ DPC_Next + !
	0 dpc@ DPC_Context1 + !
	0 dpc@ DPC_Context2 + !

	0 ok!
end

fn KeDPCEnqueue { context1 context2 importance dpc -- }
	auto ipl
	IPLHIGH KeIPLRaise ipl!

	if (dpc@ DPC_Enqueued + @)
		"KeDPCEnqueue: attempt to queue an enqueued DPC\n" KeCrash
	end

	context1@ dpc@ DPC_Context1 + !
	context2@ dpc@ DPC_Context2 + !

	auto dpch
	KeDPCListHead@ dpch!

	if (dpch@)
		if (importance@ DPCHIGHIMPORTANCE ==) // put it in front
			dpc@ KeDPCListHead!
			dpch@ dpc@ DPC_Next + !
		end else // put it in the back
			KeDPCListTail@ dpch!

			0 dpc@ DPC_Next + !
			dpc@ dpch@ DPC_Next + !
			dpc@ KeDPCListTail!
		end
	end else
		0 dpc@ DPC_Next + !
		dpc@ KeDPCListHead!
		dpc@ KeDPCListTail!
	end

	1 dpc@ DPC_Enqueued + !

	ipl@ KeIPLLower
end

var KeDPCActive 0
public KeDPCActive

// must be called with interrupts disabled, at IPLDPC
fn KeDPCDispatchQueue { rs -- }
	if (KeDPCActive@)
		return
	end

	1 KeDPCActive!

	while (KeDPCListHead@)
		auto dpc
		KeDPCListHead@ dpc!

		0 KeDPCListHead!
		0 KeDPCListTail!

		while (dpc@)
			rs@ HALCPUInterruptRestore

			dpc@ DPC_Context1 + @ dpc@ DPC_Context2 + @ dpc@ DPC_Function + @ DPCFunction

			HALCPUInterruptDisable rs!

			0 dpc@ DPC_Enqueued + !

			auto ndpc
			dpc@ DPC_Next + @ ndpc!
			0 dpc@ DPC_Next + !
			ndpc@ dpc!
		end
	end

	0 KeDPCActive!
end
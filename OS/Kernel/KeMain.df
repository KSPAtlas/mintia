#include "<df>/dragonfruit.h"
#include "<inc>/HALLog.h"

#include "<inc>/KeCrash.h"
#include "<inc>/KeIPL.h"

#include "<inc>/KeMem.h"

#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"

#include "<inc>/KeDPC.h"
#include "<inc>/KeTime.h"
#include "<inc>/KeTimer.h"

#include "<inc>/KeProcess.h"

extern KeInterruptInit { -- }

extern KeMemInit { -- }

extern KeTimerInit { -- }

extern KeSecurityInit { -- }

extern KeProcessInit { -- }

extern KeThreadInit { -- }

buffer TestThread1 KeThread_SIZEOF

buffer TestThread2 KeThread_SIZEOF

buffer KeProcessKernelThreadMain KeThread_SIZEOF

fn KeMain { -- ret }
	// early init that takes place before there's a process context

	IPLDPC KeIPLLower

	KeInterruptInit

	KeTimerInit

	KeMemInit

	KeSecurityInit

	KeProcessInit

	KeThreadInit

	0 0 pointerof KeMainInThreadContext "main" KeProcessKernelThreadMain KeThreadWorkerInitialize ret!

	if (ret@)
		ret@ "KeMain: couldn't initialize kernel main thread (%i)\n" KeCrash
	end

	0xBBBBBBBB 'o' pointerof TestKernelThread "bthread" TestThread1 KeThreadWorkerInitialize ret!

	0xCCCCCCCC 'c' pointerof TestKernelThread "cthread" TestThread2 KeThreadWorkerInitialize ret!

	PRIORITY_LOWREALTIME TestThread2 KeThread_BasePriority + !
	PRIORITY_LOWREALTIME TestThread2 KeThread_Priority + !

	KeThreadNextPick KeThreadSwitch

	0 ret!
end

var KeThreadBigTest 0

fn KeIdleThread { -- }
	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the idle thread is never ever not ready to run.

	QUEUEBACK KeProcessKernelThreadMain KeThreadReady

	while (1)
		HALCPUHalt
	end
end

fn KeMainInThreadContext { -- }
	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	"Hello Andromeda World!\n" "KeMain" HALLog

	KeMemUsageDump

	QUEUEBACK TestThread1 KeThreadReady
	QUEUEBACK TestThread2 KeThreadReady

	while (1)
		// "=" Printf

		// QUEUEBACK KeThreadBigTest@ KeThreadReady

		// "= " Printf

		'x' Putc

		// 600 KeThreadSleep
		HALCPUHalt
	end
end

extern p { x y c -- }

asm "

;a2 - x
;a1 - y
;a0 - c
p:
	li t0, 640
	mul t0, a1, t0
	lsh t0, t0, 1
	lsh t1, a2, 1
	add t0, t0, t1
	lui t2, 0xC0100000
	mov int [t2 + t0], a0
	ret

"

var r 0

fn Sierpinski { -- }
	auto i
	0 i!

	auto z
	126 z!

	while (i@ 15876 <=)
		auto x
		i@ z@ / x!

		auto y
		i@ z@ % y!

		if (x@ y@ & ~~)
			x@ y@ 2 / ~ - z@ y@ - y@ r@ * p
		end

		1 i +=
	end

	1 r +=
end

fn TestKernelThread { context1 context2 -- }
	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	while (1)
		if (context1@ 0xCCCCCCCC ==)
			// 's' Putc
			1000 KeThreadSleep
			Sierpinski
		end else
			context2@ Putc
			HALCPUHalt
		end
	end
end
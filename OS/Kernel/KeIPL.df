#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/KeIPL.h"
#include "<inc>/KeCrash.h"
#include "<inc>/HALCPU.h"

#include "<inc>/KeDPC.h"
#include "<inc>/KeTime.h"
#include "<inc>/KeTimer.h"

#include "<inc>/KeProcess.h"

#include "<inc>/KeAPC.h"

#include "<inc>/HALInterrupt.h"

// XXX this global will NOT work out well if we ever go multiprocessor.
// though, neither will most things that we're doing.
var KeIPLCurrent IPLHIGH
public KeIPLCurrent

fn KeIPLCurrentGet { -- ipl }
	KeIPLCurrent@ ipl!
end

fn KeIPLSet { ipl -- }
	ipl@ HALPlatformIPLSet

	ipl@ KeIPLCurrent!
end

fn KeIPLRaise { newipl -- oldipl }
	auto rs
	HALCPUInterruptDisable rs!

	KeIPLCurrent@ oldipl!

	if (newipl@ oldipl@ ==)
		rs@ HALCPUInterruptRestore
		return
	end

	if (newipl@ oldipl@ <)
		[newipl@]HALIPLNames@ [oldipl@]HALIPLNames@ "IPL not greater or equal (old=%s new=%s)\n" KeCrash
	end

	newipl@ KeIPLSet

	rs@ HALCPUInterruptRestore
end

fn KeIPLLower { newipl -- }
	auto rs
	HALCPUInterruptDisable rs!

	auto oldipl
	KeIPLCurrent@ oldipl!

	if (newipl@ oldipl@ ==)
		rs@ HALCPUInterruptRestore

		return
	end

	if (newipl@ oldipl@ >)
		[newipl@]HALIPLNames@ [oldipl@]HALIPLNames@ "IPL not less or equal (old=%s new=%s)\n" KeCrash
	end

	if (newipl@ IPLDPC >=)
		newipl@ KeIPLSet

		rs@ HALCPUInterruptRestore

		return
	end

	if (oldipl@ IPLAPC >)
		// the new IPL isn't >=IPLDPC, and the old IPL was >IPLAPC.
		// this means that we've dropped below IPLDPC and may have some DPCs
		// to process.

		IPLDPC KeIPLSet

		rs@ KeDPCDispatchQueue

		rs@ HALCPUInterruptRestore

		if (KeThreadNext@)
			KeThreadNextSwitch
		end

		HALCPUInterruptDisable rs!
	end

	IPLAPC KeIPLSet

	if (newipl@ IPLAPC ==)
		rs@ HALCPUInterruptRestore

		return
	end

	// we're dropping below IPLAPC. deal with processing APCs.

	if (KeThreadCurrent@)
		rs@ HALCPUInterruptRestore

		KeAPCDispatchQueue

		HALCPUInterruptDisable rs!
	end

	newipl@ KeIPLSet

	rs@ HALCPUInterruptRestore
end

externptr HALInterruptStackTop

var KeInterruptNested 0

fn KeInterrupt { ipl int handler -- }
	auto oldipl
	ipl@ KeIPLRaise oldipl!

	if (KeInterruptNested@ ~~)
		1 KeInterruptNested!

		int@ handler@ HALInterruptStackTop@ HALCPURunInContext

		HALCPUInterruptEnable

		// XXX there is a brief window here where an interrupt can occur, and be handled outside of the interrupt stack.
		// any interrupts that are higher priority that occur during that interrupt will also be handled in the interrupted
		// thread's kernel stack, rather than the interrupt thread.

		// this is considered fine because it is only possible for interrupts to nest a max of 8 levels deep anyway, and it is
		// anticipated that the bulk of the time spent with KeInterruptNested set to 1 will be spent in the interrupt handler.

		// however, it is possible to fix this case. i just don't consider it worthwhile right now.

		oldipl@ KeIPLLower

		HALCPUInterruptDisable drop

		0 KeInterruptNested!
	end else
		HALCPUInterruptEnable

		int@ handler@ HALInterruptHandler

		HALCPUInterruptDisable drop

		// it's okay for KeIPLLower to run with interrupts disabled here because it's impossible for it to drop below IPLDPC.

		// the problem with it running with interrupts disabled, which causes the weird case above, is that DPCs must run
		// with interrupts enabled. it's totally fine here though because it's basically just setting a variable and returning
		// in this particular case.

		oldipl@ KeIPLLower
	end
end

externptr HALInterruptFunction

fn KeInterruptInit { -- }
	pointerof KeInterrupt HALInterruptFunction!
end
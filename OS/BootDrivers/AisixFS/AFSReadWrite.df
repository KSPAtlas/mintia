#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

// We don't need to worry about per-file synchronization issues in the
// filesystem specific code, because the upper-level code achieves this for
// us: If the file is uncached, the main FCB mutex will be held throughout
// the operation. If the file is cached, the cacheblock mutex will be held
// throughout the operation.

fn (IODispatchReadFunction) AFSReadFile { timeout flags length offset buffer fcb lastmode -- bytesread ok }
	auto bytesize
	fcb@ IOFileControlBlock_SizeInBytes + @ bytesize!

	auto mount
	fcb@ IOFileControlBlock_DeviceObject + @ mount!

	0 ok!

	0 bytesread!

	if (offset@ bytesize@ >=)
		return
	end

	bytesize@ offset@ -
	length@
	min length!

	while (bytesread@ length@ <)
		auto blockno
		offset@ AFSBLOCKSHIFT >> blockno!

		auto blockoff
		offset@ AFSBLOCKOFFMASK & blockoff!

		auto m

		length@ bytesread@ -
		AFSBLOCKSIZE blockoff@ -
		min m!

		blockno@ // blkoff
		fcb@ // fcb
		AFSBlockMap ok! blockno!

		if (ok@)
			return
		end

		auto br

		m@ // length
		blockno@ AFSBLOCKSHIFT << blockoff@ + // offset
		buffer@ // buf
		mount@ // mount
		FSVolumeRead ok! br!

		if (ok@)
			return
		end

		if (DEBUGCHECKS)
			if (br@ m@ ~=)
				"AFSReadFile: volume read failed\n" KeCrash
			end
		end

		m@ buffer +=
		m@ bytesread +=
		m@ offset +=
	end
end

fn (IODispatchWriteFunction) AFSWriteFile { flags length offset buffer fcb lastmode -- byteswritten ok }
	"AFSWriteFile: TODO\n" KeCrash
end
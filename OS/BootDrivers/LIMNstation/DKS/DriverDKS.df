#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALLIMNstationCitron.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/IO.h"

const DKS_REALDISK  1
const DKS_PARTITION 2

struct Disk
	4 Type
	4 DKSID
	4 BlockOffset
	4 Blocks
endstruct

const DKSMAXDISKID 7

const DKSPORTCMD 0x19
const DKSPORTA   0x1A
const DKSPORTB   0x1B

const DKSCMDSELECT  0x1
const DKSCMDREAD    0x2
const DKSCMDWRITE   0x3
const DKSCMDINFO    0x4
const DKSCMDPOLL    0x5
const DKSCMDINTR    0x6
const DKSCMDINTROFF 0x7

const DKSINTERRUPT  0x3

const DKSBLOCKTRANSFER 0x0

table DriverDKSDispatch
	pointerof DriverDKSOpen              // open
	pointerof DriverDKSClose             // close
	pointerof DriverDKSIOControl         // iocontrol
	pointerof DriverDKSRead              // read
	pointerof DriverDKSWrite             // write
	0                                    // system control
	0                                    // parse
	0                                    // create
	0                                    // flush
	0                                    // delete object
	0                                    // set information
	0                                    // get information
	0                                    // rename
	pointerof DriverDKSReadBlock         // readblock
	pointerof DriverDKSWriteBlock        // writeblock
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

table DriverDKS
	IOVERSION_MAJOR                      // ioversion major
	IOVERSION_MINOR                      // ioversion minor

	"dks"                                // name
	OSFILETYPE_BLOCKDEVICE               // type
	pointerof DriverDKSDispatch          // dispatch table
	Disk_SIZEOF                          // extension size
endtable

buffer DKSMutex KeMutex_SIZEOF
buffer DKSEvent KeEvent_SIZEOF

buffer DKSDPC KeDPC_SIZEOF

externptr HALLIMNstationDKSBuffer

fn (FDriverInit) DriverInit { stage -- ok }
	if (stage@ STAGE_THREAD ==)
		"DKSMutex" // name
		KERNELMODE // mode
		DKSMutex // mutex
		KeMutexInitialize ok!

		if (ok@)
			"DKSDriverInit: mutex initialization failed\n" KeCrash
		end

		0 // signaled
		KEEVENT_SYNCH // type
		"DKSEvent" // name
		DKSEvent // event
		KeEventInitialize ok!

		if (ok@)
			"DKSDriverInit: failed to initialize event\n" KeCrash
		end

		pointerof DriverDKSDPCFunction // function
		DKSDPC // dpc
		KeDPCInitialize ok!

		if (ok@)
			ok@ "DKSDriverInit: failed to initialize DPC\n" KeCrash
		end

		// detect and register disks

		auto diskid
		0 diskid!

		auto namebuf
		64 alloc namebuf!

		namebuf@ // dest
		"Dks" // src
		strcpy

		auto dev
		auto disk

		while (diskid@ DKSMAXDISKID <=)
			auto present
			auto blocks

			diskid@ DKSPORTA HALLIMNstationCitronOutl

			DKSCMDPOLL DKSPORTCMD HALLIMNstationCitronCommand

			DKSPORTA HALLIMNstationCitronInl present!
			DKSPORTB HALLIMNstationCitronInl blocks!

			if (present@ 1 &)
				// we have a disk at this ID

				diskid@ // n
				namebuf@ 3 + // buf
				itoa

				blocks@ namebuf@ diskid@ "ID %d: NAME=/Devices/%s BLOCKSZ=4096 BLOCKS=%d\n" "DKSDriverInit" HALLog

				auto sizeinbytes

				if (blocks@ 1048576 <)
					blocks@ 12 << sizeinbytes!

					namebuf@ // name
					sizeinbytes@ // sizeinbytes
					DriverDKS // driver
					ACCESS_OWNER_ALL ACCESS_GROUP_ALL | // permissions
					IODeviceCreate ok! dev!

					if (ok@)
						ok@ "DKSDriverInit: failed to create device object (%i)\n" KeCrash
					end

					4096 dev@ IODevice_BlockSize + !

					dev@ IODevice_Extension + @ disk!

					DKS_REALDISK disk@ Disk_Type + !
					diskid@ disk@ Disk_DKSID + !
					0 disk@ Disk_BlockOffset + !
					blocks@ disk@ Disk_Blocks + !
				end else
					namebuf@ "%s: disk is >=4GB; this is not supported! skipping.\n" "DKSDriverInit" HALLog
				end
			end

			1 diskid +=
		end

		pointerof DriverDKSInterrupt // function
		DKSINTERRUPT // interrupt number
		IPLDISK // interrupt priority level
		HALInterruptRegister

		DKSCMDINTR DKSPORTCMD HALLIMNstationCitronCommand
	end

	0 ok!
end

fn (DPCFunction) DriverDKSDPCFunction { context1 context2 -- }
	// actually wake up blocked readers following a disk transfer interrupt

	IOBOOSTDISK // priboost
	DKSEvent // event
	KeEventSignal drop
end

fn (HALInterruptHandler) DriverDKSInterrupt { int -- }
	auto event
	auto details

	DKSCMDINFO DKSPORTCMD HALLIMNstationCitronCommand
	DKSPORTA HALLIMNstationCitronInl event!
	DKSPORTB HALLIMNstationCitronInl details!

	if (event@ DKSBLOCKTRANSFER ==)
		auto dpc
		DKSDPC dpc!

		if (dpc@ KeDPC_Enqueued + @ ~~)
			// defer waking up any blocked readers til later,
			// otherwise we will BSOD since we're at IPLDISK

			0 // context1
			0 // context2
			DPCLOWIMPORTANCE // importance
			dpc@ // dpc
			KeDPCEnqueue
		end
	end
end

fn DKSLock { -- ok }
	KERNELMODE // waitmode
	1 // alertable
	TIMEOUTINFINITE // timeout
	DKSMutex // object
	KeThreadWaitForObject ok!
end

fn DKSUnlock { -- }
	DKSMutex KeMutexRelease drop
end

var DKSLastDisk 0
var DKSLastBlockNo 0

fn DKSBlockReadCommand { blockno disk -- ok }
	if (DEBUGCHECKS)
		if (DKSMutex KeMutexIsLocked ~~)
			"DKSBlockRead: DKSMutex should have been locked\n" KeCrash
		end
	end

	if (DKSLastBlockNo@ blockno@ ==)
		if (DKSLastDisk@ disk@ ==)
			// utilize the DKS buffer memory as a one-block cache:
			// if the contents of this block are already present in
			// the buffer, just return. this should cut way down on
			// redundant reads during uncached accesses.

			0 ok!

			return
		end
	end

	// read blockno from disk into DKS buffer memory

	auto rs
	HALCPUInterruptDisable rs!

	disk@ Disk_DKSID + @ DKSPORTA HALLIMNstationCitronOutl
	DKSCMDSELECT DKSPORTCMD HALLIMNstationCitronCommand

	blockno@ DKSPORTA HALLIMNstationCitronOutl
	DKSCMDREAD DKSPORTCMD HALLIMNstationCitronCommandASync

	rs@ HALCPUInterruptRestore

	KERNELMODE // waitmode
	0 // alertable
	TIMEOUTINFINITE // timeout
	DKSEvent // object
	KeThreadWaitForObject ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "DKSBlockRead: couldn't wait on event (%i)\n" KeCrash
		end
	end

	disk@ DKSLastDisk!
	blockno@ DKSLastBlockNo!
end

fn DKSBlockWriteCommand { blockno disk -- ok }
	if (DEBUGCHECKS)
		if (DKSMutex KeMutexIsLocked ~~)
			"DKSBlockRead: DKSMutex should have been locked\n" KeCrash
		end
	end

	// write DKS buffer memory into blockno

	auto rs
	HALCPUInterruptDisable rs!

	disk@ Disk_DKSID + @ DKSPORTA HALLIMNstationCitronOutl
	DKSCMDSELECT DKSPORTCMD HALLIMNstationCitronCommand

	blockno@ disk@ Disk_BlockOffset + @ + DKSPORTA HALLIMNstationCitronOutl
	DKSCMDWRITE DKSPORTCMD HALLIMNstationCitronCommandASync

	rs@ HALCPUInterruptRestore

	KERNELMODE // waitmode
	0 // alertable
	TIMEOUTINFINITE // timeout
	DKSEvent // object
	KeThreadWaitForObject ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "DKSBlockWrite: couldn't wait on event (%i)\n" KeCrash
		end
	end

	disk@ DKSLastDisk!
	blockno@ DKSLastBlockNo!
end

fn (IODispatchOpenFunction) DriverDKSOpen { fileobject -- ok }
	0 ok!
end

fn (IODispatchCloseFunction) DriverDKSClose { fileobject -- ok }
	0 ok!
end

fn (IODispatchIOControlFunction) DriverDKSIOControl { arg1 arg2 arg3 arg4 fileobject -- ok }
	0 ok!
end

// routines for I/O by byte offset.
// these are only called when the device object is opened directly, either cached or uncached.
// if caller isn't careful these can lead to some redundant reads and writes.

fn (IODispatchReadFunction) DriverDKSRead { flags length bufsize offset buffer fileobject lastmode -- bytesread ok }
	auto disk
	fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DeviceObject + @ IODevice_Extension + @ disk!

	auto blocksize
	fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DeviceObject + @ IODevice_BlockSize + @ blocksize!

	auto bytesize
	fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_SizeInBytes + @ bytesize!

	0 ok!

	0 bytesread!

	if (offset@ bytesize@ >=)
		return
	end

	offset@ bytesize@ -
	length@
	min length!

	while (bytesread@ length@ <)
		if (bytesread@ bufsize@ ==)
			STATUS_BUFFER_MAXIMUM ok!

			return
		end

		if (DEBUGCHECKS)
			if (bytesread@ bufsize@ >)
				"DriverDKSRead: bytesread > bufsize\n" KeCrash
			end
		end

		auto blockno
		offset@ blocksize@ / blockno!

		auto blockoff
		offset@ blocksize@ % blockoff!

		auto m

		length@ bytesread@ -
		blocksize@ blockoff@ -
		min
		bufsize@ bytesread@ -
		min m!

		DKSLock ok!

		if (ok@)
			return
		end

		blockno@ disk@ DKSBlockReadCommand ok!

		if (ok@)
			DKSUnlock

			return
		end

		buffer@ // dest
		HALLIMNstationDKSBuffer@ blockoff@ + // src
		m@ // size
		memcpy

		DKSUnlock

		m@ buffer +=
		m@ bytesread +=
	end
end

fn (IODispatchWriteFunction) DriverDKSWrite { flags length bufsize offset buffer fileobject lastmode -- byteswritten ok }
	auto disk
	fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DeviceObject + @ IODevice_Extension + @ disk!

	auto blocksize
	fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DeviceObject + @ IODevice_BlockSize + @ blocksize!

	auto bytesize
	fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_SizeInBytes + @ bytesize!

	0 ok!

	0 byteswritten!

	if (offset@ bytesize@ >=)
		return
	end

	offset@ bytesize@ -
	length@
	min length!

	while (byteswritten@ length@ <)
		if (byteswritten@ bufsize@ ==)
			STATUS_BUFFER_MAXIMUM ok!

			return
		end

		if (DEBUGCHECKS)
			if (byteswritten@ bufsize@ >)
				"DriverDKSWrite: byteswritten > bufsize\n" KeCrash
			end
		end

		auto blockno
		offset@ blocksize@ / blockno!

		auto blockoff
		offset@ blocksize@ % blockoff!

		auto m

		length@ byteswritten@ -
		blocksize@ blockoff@ -
		min
		bufsize@ byteswritten@ -
		min m!

		DKSLock ok!

		if (ok@)
			return
		end

		if (m@ blocksize@ ~=)
			blockno@ disk@ DKSBlockReadCommand ok!

			if (ok@)
				DKSUnlock

				return
			end
		end

		HALLIMNstationDKSBuffer@ blockoff@ + // dest
		buffer@ // src
		m@ // size
		memcpy

		blockno@ disk@ DKSBlockWriteCommand ok!

		if (ok@)
			DKSUnlock

			return
		end

		DKSUnlock

		m@ buffer +=
		m@ byteswritten +=
	end
end

// routines for I/O by block offset.
// these are only called directly by a mounted filesystem.

fn (IODispatchWriteBlockFunction) DriverDKSWriteBlock { blockno bufsize buffer devobject -- ok }
	// write by block

	auto disk
	devobject@ IODevice_Extension + @ disk!

	auto blocksize
	devobject@ IODevice_BlockSize + @ blocksize!

	if (blockno@ disk@ Disk_Blocks + @ >=)
		STATUS_IO_END_OF_DISK ok!

		return
	end

	auto towrite
	blocksize@ bufsize@ min towrite!

	DKSLock ok!

	if (ok@)
		return
	end

	HALLIMNstationDKSBuffer@ // dest
	buffer@ // src
	towrite@ // size
	memcpy

	blockno@ disk@ DKSBlockWriteCommand ok!

	DKSUnlock
end

fn (IODispatchReadBlockFunction) DriverDKSReadBlock { blockno bufsize buffer devobject -- ok }
	// read by block

	auto disk
	devobject@ IODevice_Extension + @ disk!

	auto blocksize
	devobject@ IODevice_BlockSize + @ blocksize!

	if (blockno@ disk@ Disk_Blocks + @ >=)
		STATUS_IO_END_OF_DISK ok!

		return
	end

	auto toread
	blocksize@ bufsize@ min toread!

	DKSLock ok!

	if (ok@)
		return
	end

	blockno@ disk@ DKSBlockReadCommand ok!

	if (ok@)
		DKSUnlock

		return
	end

	buffer@ // dest
	HALLIMNstationDKSBuffer@ // src
	toread@ // size
	memcpy

	DKSUnlock
end
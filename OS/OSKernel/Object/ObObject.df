#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Object.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn ObObjectClose { handle -- ok }
	handle@
	KeProcessCurrent
	ObObjectCloseProcess ok!
end

fn ObObjectCloseProcess { handle process -- ok }
	auto handletable
	process@ PsProcess_HandleTable + @ handletable!

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"ObObjectCloseProcess: ipl != IPLLOW\n" KeCrash
		end

		if (handletable@ ~~)
			"ObObjectCloseProcess: process has no handle table\n" KeCrash
		end
	end

	auto object

	handle@ // handle
	handletable@ // handletable
	0 // locked
	ExHandleDelete ok! object!

	if (ok@)
		return
	end

	if (DEBUGCHECKS)
		if (object@ ~~)
			"ObObjectCloseProcess: object was null\n" KeCrash
		end
	end

	auto obh
	object@ ObHeader_SIZEOF - obh!

	obh@ ObHeader_QuotaCharge + @
	process@ MmQuotaUnchargeProcess

	object@ ObObjectHandleCountDecrement drop

	auto type
	obh@ ObHeader_TypeObject + @ type!

	if (type@)
		auto closefunc
		type@ ObType_CloseFunction + @ closefunc!

		if (closefunc@)
			object@ process@ closefunc@ ObTypeCloseFunction
		end
	end

	object@ ObObjectDereferenceByPointer drop
end

fn ObObjectOpen { access object -- handle ok }
	access@
	object@
	KeProcessCurrent
	ObObjectOpenProcess ok! handle!
end

fn ObObjectOpenProcess { access object process -- handle ok }
	auto handletable
	process@ PsProcess_HandleTable + @ handletable!

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"ObObjectOpenProcess: ipl != IPLLOW\n" KeCrash
		end

		if (handletable@ ~~)
			"ObObjectOpenProcess: process has no handle table\n" KeCrash
		end
	end

	auto obh
	object@ ObHeader_SIZEOF - obh!

	handletable@ ExHandleTableLock ok!

	if (ok@)
		return
	end

	obh@ ObHeader_QuotaCharge + @
	process@ MmQuotaChargeProcess ok!

	if (ok@)
		return
	end

	auto entryptr

	object@ // entryvalue
	handletable@ // handletable
	1 // locked
	ExHandleCreate ok! entryptr! handle!

	if (ok@)
		obh@ ObHeader_QuotaCharge + @
		process@ MmQuotaUnchargeProcess

		handletable@ ExHandleTableUnlock

		return
	end

	access@ entryptr@ ObObjectTableEntry_Access + !

	object@ ObObjectHandleCountIncrement drop

	auto type
	obh@ ObHeader_TypeObject + @ type!

	if (type@)
		auto openfunc
		type@ ObType_OpenFunction + @ openfunc!

		if (openfunc@)
			object@ process@ openfunc@ ObTypeOpenFunction drop
		end
	end

	handletable@ ExHandleTableUnlock
end

fn ObObjectReferenceByHandle { type handle -- access object ok }
	type@
	handle@
	KeProcessCurrent
	ObObjectReferenceByHandleProcess ok! object! access!
end

fn ObObjectReferenceByHandleProcess { type handle process -- access object ok }
	auto handletable
	process@ PsProcess_HandleTable + @ handletable!

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"ObObjectReferenceByHandleProcess: ipl != IPLLOW\n" KeCrash
		end

		if (handletable@ ~~)
			"ObObjectReferenceByHandleProcess: process has no handle table\n" KeCrash
		end
	end

	handletable@ ExHandleTableLock ok!

	if (ok@)
		return
	end

	auto entryptr

	handle@ // handle
	handletable@ // handletable
	1 // locked
	ExHandleLookup ok! entryptr!

	if (ok@)
		handletable@ ExHandleTableUnlock

		return
	end

	if (type@)
		if (object@ ObHeader_TypeObject + @ type@ ~=)
			handletable@ ExHandleTableUnlock

			STATUS_INVALID_OBJECT_TYPE ok!

			return
		end
	end

	entryptr@ ObObjectTableEntry_Object + @ object!
	entryptr@ ObObjectTableEntry_Access + @ access!

	object@ ObObjectReferenceByPointer drop

	handletable@ ExHandleTableUnlock
end

fn ObObjectHandleCountIncrement { object -- oldcount }
	ObHeader_SIZEOF object -=

	auto rs
	HALCPUInterruptDisable rs!

	object@ ObHeader_HandleCount + @ oldcount!

	oldcount@ 1 + object@ ObHeader_HandleCount + !

	rs@ HALCPUInterruptRestore
end

fn ObObjectHandleCountDecrement { object -- oldcount }
	ObHeader_SIZEOF object -=

	auto rs
	HALCPUInterruptDisable rs!

	object@ ObHeader_HandleCount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"ObObjectHandleCountDecrement: attempt to decrement below 0\n" KeCrash
		end

		// if (oldcount@ object@ ObHeader_PointerCount + @ ==)
		// 	"ObObjectHandleCountDecrement: attempt to decrement below pointer count\n" KeCrash
		// end
	end

	oldcount@ 1 - object@ ObHeader_HandleCount + !

	rs@ HALCPUInterruptRestore
end

fn ObObjectReferenceByPointer { object -- oldcount }
	ObHeader_SIZEOF object -=

	auto rs
	HALCPUInterruptDisable rs!

	object@ ObHeader_PointerCount + @ oldcount!

	oldcount@ 1 + object@ ObHeader_PointerCount + !

	rs@ HALCPUInterruptRestore
end

fn ObObjectDereferenceByPointer { object -- oldcount }
	ObHeader_SIZEOF object -=

	auto rs
	HALCPUInterruptDisable rs!

	object@ ObHeader_PointerCount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"ObObjectDereferenceByPointer: underflow\n" KeCrash
		end

		// if (oldcount@ 1 - object@ ObHeader_HandleCount + @ <)
		// 	"ObObjectDereferenceByPointer: pointer count < handle count\n" KeCrash
		// end
	end

	oldcount@ 1 - object@ ObHeader_PointerCount + !

	rs@ HALCPUInterruptRestore

	auto ok

	if (oldcount@ 1 ==)
		// just decremented the pointer count to zero. delete the object

		if (KeIPLCurrentGet IPLLOW ==)
			// delete immediately

			object@ ObHeader_SIZEOF + ObObjectFree ok!

			if (DEBUGCHECKS)
				if (ok@)
					"ObObjectDereferenceByPointer: failed to free object\n" KeCrash
				end
			end
		end else
			// can't delete objects at >=IPLAPC, queue a work item

			"ObObjectDereferenceByPointer: work items NYI\n" KeCrash
		end
	end
end
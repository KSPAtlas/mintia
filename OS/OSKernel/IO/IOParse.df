#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn (ObTypeParseFunction) IOParse { flags path initialobject process -- reparsepath object ok }
	0 reparsepath!

	auto type
	initialobject@ ObHeader_SIZEOF - ObHeader_TypeObject + @ type!

	if (type@ IODeviceTypeObject@ ==)
		if (path@ gb 0 ==)
			// no remaining path means we are opening the device itself.
			// create a file object for the device.

			flags@ // flags
			process@ PsProcess_OwningUser + @ // owninguser
			IOFileCreateObject ok! object!

			if (ok@)
				return
			end

			initialobject@ object@ IOFile_DeviceObject + !

			OSFILETYPE_DEVICE object@ IOFile_Type + !

			return
		end else
			// remaining path, call mounted filesystem (if any) to resolve it

			"IOParse: NYI 1\n" KeCrash
		end
	end elseif (type@ IOFileTypeObject@ ==)
		if (path@ gb 0 ==)
			// no remaining path means we are just going to return the same file object.

			// XXX we should probably create a whole new one instead of returning the same one... will come up later.

			0 ok!

			initialobject@ ObObjectReferenceByPointer drop

			initialobject@ object!

			return
		end elseif (initialobject@ IOFile_Type + @ OSFILETYPE_DIRECTORY ==)
			// remaining path and directory type means we need to call into the filesystem 

			"IOParse: NYI 2\n" KeCrash
		end else
			// remaining path, but not directory type

			STATUS_NOT_A_DIRECTORY ok!

			return
		end
	end else
		"IOParse: unknown type\n" KeCrash
	end
end
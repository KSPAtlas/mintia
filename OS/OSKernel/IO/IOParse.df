#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn (ObTypeParseFunction) IOParse { flags path initialobject process -- reparsepath object ok }
	0 reparsepath!

	auto type
	initialobject@ ObHeader_SIZEOF - ObHeader_TypeObject + @ type!

	auto fcb
	auto mount

	if (type@ IODeviceTypeObject@ ==)
		initialobject@ IODevice_FileControlBlock + @ fcb!

		if (path@ gb ~~)
			// no remaining path means we are opening the device itself.
			// create a file object for the device.

			// TODO return an error if this is a disk image proxy,
			// since this would be a bit of a nonsensical operation;
			// caller should open the disk image by its actual
			// path.

			flags@ // flags
			process@ PsProcess_OwningUser + @ // owninguser
			fcb@ // fcb
			IOFileCreateObject ok! object!

			if (ok@ 0 ==)
				flags@ // flags
				fcb@ // fcb
				IOFileControlBlockAcquireCheck ok!

				if (ok@)
					object@ ObObjectDereferenceByPointer drop
				end
			end

			return
		end else
			// we only need to do this check here, where we're
			// going from a device object to a file object on the filesystem,
			// and not below, where we're going from a file object to a file object,
			// because the ref operation implied by having that file object precludes
			// nasty stuff from happening anyway.

			auto rs
			HALCPUInterruptDisable rs!

			fcb@ IOFileControlBlock_Mount + @ mount!

			if (fcb@ IOFileControlBlock_Busy + @)
				rs@ HALCPUInterruptRestore

				STATUS_IO_TRY_AGAIN_LATER ok!

				return
			end elseif (mount@ ~~)
				rs@ HALCPUInterruptRestore

				STATUS_NOT_A_DIRECTORY ok!

				return
			end

			1 fcb@ IOFileControlBlock_ParseCount + +=

			rs@ HALCPUInterruptRestore

			// remaining path, call mounted filesystem (if any) to resolve it

			"IOParse: NYI 1\n" KeCrash

			HALCPUInterruptDisable rs!

			if (DEBUGCHECKS)
				if (fcb@ IOFileControlBlock_ParseCount + @ 0 ==)
					"IOParse: underflow 1\n" KeCrash
				end
			end

			1 fcb@ IOFileControlBlock_ParseCount + -=

			rs@ HALCPUInterruptRestore
		end
	end elseif (type@ IOFileTypeObject@ ==)
		// we need to call into the filesystem whether there is remaining path or not,
		// in order to open this new file object correctly

		"IOParse: NYI 2\n" KeCrash
	end else
		"IOParse: unknown type\n" KeCrash
	end
end
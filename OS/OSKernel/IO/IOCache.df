#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

table IOCacheEvictableFunctions
	pointerof IOCachePageEvictionFunction // EvictionFunc
	pointerof IOCachePageReferenceFunction // ReferenceFunc
	pointerof IOCachePageDereferenceFunction // DereferenceFunc
	pointerof IOCachePageModifyFunction // ModifyFunc
	0 // Reserved2
	0 // Reserved3
	0 // Reserved4
	0 // Reserved5
endtable

var IOCacheModifiedPageListHead 0
public IOCacheModifiedPageListHead

var IOCacheModifiedPageListTail 0
public IOCacheModifiedPageListTail

fn IOCacheInfoBlockCreate { -- cacheblock ok }
	IOCacheInfoBlock_SIZEOF // bytes
	'Cach' // tag
	MmAllocWithTag ok! cacheblock!

	if (ok@)
		// allocation failed

		return
	end

	"IOCacheInfoBlockMutex" // name
	KERNELMODE // mode
	cacheblock@ IOCacheInfoBlock_Mutex + // mutex
	KeMutexInitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			"IOCacheInfoBlockCreate: couldn't initialize mutex\n" KeCrash
		end
	end

	0 cacheblock@ IOCacheInfoBlock_PageReferences + !
	0 cacheblock@ IOCacheInfoBlock_ModifiedPages + !
	0 cacheblock@ IOCacheInfoBlock_Flags + !

	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + // ptr
	IOCACHEPAGEBUCKETS 8 * // size
	0 // word
	memset
end

fn IOCacheInfoBlockLock { cacheblock -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	cacheblock@ IOCacheInfoBlock_Mutex + // object
	KeThreadWaitForObject ok!
end

fn IOCacheInfoBlockTryLock { cacheblock -- locked }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	cacheblock@ IOCacheInfoBlock_Mutex + // object
	KeThreadWaitForObject locked!
end

fn IOCacheInfoBlockUnlock { cacheblock -- }
	cacheblock@ IOCacheInfoBlock_Mutex + KeMutexRelease drop
end

fn IOCacheInfoBlockReference { cacheblock -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	cacheblock@ IOCacheInfoBlock_PageReferences + @ oldcount!

	oldcount@ 1 + cacheblock@ IOCacheInfoBlock_PageReferences + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockTryReference { cacheblock -- oldcount ok }
	0 ok!

	auto rs
	HALCPUInterruptDisable rs!

	if (cacheblock@ IOCacheInfoBlock_Flags + @ IOCACHEBLOCKFLAG_TRUNCATING &)
		rs@ HALCPUInterruptRestore

		STATUS_IO_TRY_AGAIN_LATER ok!

		return
	end

	cacheblock@ IOCacheInfoBlock_PageReferences + @ oldcount!

	oldcount@ 1 + cacheblock@ IOCacheInfoBlock_PageReferences + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockDereference { cacheblock -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	cacheblock@ IOCacheInfoBlock_PageReferences + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"IOCacheInfoBlockDereference: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - cacheblock@ IOCacheInfoBlock_PageReferences + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockTruncate { writeout cacheblock -- ok }
	// attempt to evict all of the cacheblock's page frames.
	// caller should have locked the associated FCB as necessary.

	cacheblock@ // cacheblock
	IOCacheInfoBlockLock ok!

	if (ok@)
		return
	end

	auto rs
	HALCPUInterruptDisable rs!

	if (cacheblock@ IOCacheInfoBlock_ModifiedPages + @ cacheblock@ IOCacheInfoBlock_PageReferences + @ ~=)
		// one or more page frames in this cache is currently in use.
		// don't allow truncation for now.

		rs@ HALCPUInterruptRestore

		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlock

		if (DEBUGCHECKS)
			if (cacheblock@ IOCacheInfoBlock_PageReferences + @ cacheblock@ IOCacheInfoBlock_ModifiedPages + @ <)
				"IOCacheInfoBlockTruncate: page references < modified page count\n" KeCrash
			end
		end

		STATUS_IO_TRY_AGAIN_LATER ok!

		return
	end

	IOCACHEBLOCKFLAG_TRUNCATING cacheblock@ IOCacheInfoBlock_Flags + |=

	rs@ HALCPUInterruptRestore

	if (DEBUGCHECKS)
		if (cacheblock@ IOCacheInfoBlock_PageReferences + @ cacheblock@ IOCacheInfoBlock_ModifiedPages + @ ~=)
			// they should both either be zero (all modified pages written out and zero other references),
			// or both be equal (only modified pages, and writeout==0)

			cacheblock@ IOCacheInfoBlock_ModifiedPages + @
			cacheblock@ IOCacheInfoBlock_PageReferences + @
			"IOCacheInfoBlockTruncate: page references (%d) != modified page count (%d)\n" KeCrash
		end
	end

	// iterate each bucket from 0 to IOCACHEPAGEBUCKETS-1.
	// for each bucket, free all cached pages. if a page is modified,
	// and caller wanted us to write out dirty pages (writeout==1),
	// write the page out first.

	auto i
	0 i!

	while (i@ IOCACHEPAGEBUCKETS <)
		auto buckethead
		cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + buckethead!

		auto pfdbe

		// get the tail so that we can go backwards thru the bucket.
		// reason for this is that LRU -> MRU is the most likely
		// order to go "in order" on the disk surface
		buckethead@ 4 + @ pfdbe!

		while (pfdbe@)
			if (DEBUGCHECKS)
				if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
					if (pfdbe@ IOPageFrameEntryCache_References + @ 1 ~=)
						pfdbe@
						pfdbe@ IOPageFrameEntryCache_References + @
						"IOCacheInfoBlockTruncate: found page with odd refcount %d (0x%08x)\n" KeCrash
					end
				end elseif (pfdbe@ IOPageFrameEntryCache_References + @ 0 ~=)
					pfdbe@
					pfdbe@ IOPageFrameEntryCache_References + @
					"IOCacheInfoBlockTruncate: found page with odd refcount %d (0x%08x)\n" KeCrash
				end
			end

			auto wroteout
			0 wroteout!

			if (writeout@)
				if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
					// this is a modified page, and caller wants us to write them out to disk.
					// the alternative is writeout==0, which means the caller says its fine
					// to ignore and throw them out.

					1 // dontunbias
					pfdbe@ // pfdbe
					IOCachePageWriteModified drop

					1 wroteout!
				end
			end

			if (wroteout@ ~~)
				pfdbe@ MmEvictablePageReference drop
			end

			auto npfdbe

			// get this now, because who knows what MmPageFree will do to the field where PrevCachePage is stored
			pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ npfdbe!

			pfdbe@ IOPageFrameEntryCache_PFN + @ // pfn
			MmPageFree

			npfdbe@ pfdbe!
		end

		// set buckethead and buckettail to null to reflect that it is now empty
		0 buckethead@!
		0 buckethead@ 4 + !

		1 i +=
	end

	0 cacheblock@ IOCacheInfoBlock_ModifiedPages + !
	0 cacheblock@ IOCacheInfoBlock_PageReferences + !

	HALCPUInterruptDisable rs!

	IOCACHEBLOCKFLAG_TRUNCATING ~ cacheblock@ IOCacheInfoBlock_Flags + &=

	rs@ HALCPUInterruptRestore

	cacheblock@ // cacheblock
	IOCacheInfoBlockUnlock
end

fn IOCacheInfoBlockDestroy { writeout cacheblock -- ok }
	writeout@ // writeout
	cacheblock@ // cacheblock
	IOCacheInfoBlockTruncate ok!

	if (ok@ 0 ==)
		cacheblock@ MmFree
	end
end

fn IOCachePageRemoveModified { pfdbe -- }
	auto rs
	HALCPUInterruptDisable rs!

	// remove from modified list
	auto n
	pfdbe@ MmPageFrameEntryEvictable_Next + @ n!

	if (n@)
		pfdbe@ MmPageFrameEntryEvictable_Prev + @ n@ MmPageFrameEntryEvictable_Prev + !
	end else // no next means we were the tail
		pfdbe@ MmPageFrameEntryEvictable_Prev + @ IOCacheModifiedPageListTail!
	end

	auto p
	pfdbe@ MmPageFrameEntryEvictable_Prev + @ p!

	if (p@)
		pfdbe@ MmPageFrameEntryEvictable_Next + @ p@ MmPageFrameEntryEvictable_Next + !
	end else // no prev means we were the head
		pfdbe@ MmPageFrameEntryEvictable_Next + @ IOCacheModifiedPageListHead!
	end

	rs@ HALCPUInterruptRestore
end

fn IOCachePageInsertModified { pfdbe -- }
	auto rs
	HALCPUInterruptDisable rs!

	// use the evict LRU links to insert the page on the back of the modified list

	auto t
	IOCacheModifiedPageListTail@ t!

	if (t@ ~~)
		0 pfdbe@ MmPageFrameEntryEvictable_Next + !
		0 pfdbe@ MmPageFrameEntryEvictable_Prev + !

		pfdbe@ IOCacheModifiedPageListHead!
		pfdbe@ IOCacheModifiedPageListTail!
	end else
		0 pfdbe@ MmPageFrameEntryEvictable_Next + !

		t@ pfdbe@ MmPageFrameEntryEvictable_Prev + !
		pfdbe@ t@ MmPageFrameEntryEvictable_Next + !
		pfdbe@ IOCacheModifiedPageListTail!
	end

	rs@ HALCPUInterruptRestore
end

fn IOCachePageWriteModified { dontunbias pfdbe -- ok }
	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto rs
	HALCPUInterruptDisable rs!

	if (DEBUGCHECKS)
		if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY & ~~)
			pfdbe@ "IOCachePageWriteModified: page wasn't dirty (0x%08x)\n" KeCrash
		end
	end

	// clear dirty flag
	IOCACHEPAGEFLAG_DIRTY ~ pfdbe@ IOPageFrameEntryCache_Flags + &=

	// decrement modified page count

	if (DEBUGCHECKS)
		if (cacheblock@ IOCacheInfoBlock_ModifiedPages + @ 0 ==)
			"IOCachePageWriteModified: underflow\n" KeCrash
		end
	end

	1 cacheblock@ IOCacheInfoBlock_ModifiedPages + -=

	// remove from modified list
	pfdbe@ IOCachePageRemoveModified

	// if there's a modified PTE somewhere, clear the writable bit so that
	// the next time the process writes to it, this page gets properly
	// marked as dirty again

	if (pfdbe@ IOPageFrameEntryCache_ModifiedPTE + @)
		pfdbe@ "IOCachePageWriteModified: TODO: clear writable bit in PTE\n" KeCrash
	end

	rs@ HALCPUInterruptRestore

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	// perform the write operation

	auto off
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

	auto len

	if (DEBUGCHECKS)
		if (off@ fcb@ IOFileControlBlock_SizeInBytes + @ >=)
			pfdbe@ "IOCachePageWriteModified: modified page offset beyond end of file (0x%08x)\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_SizeInBytes + @ off@ -
	PAGESIZE min len!

	OSACCESSFLAG_BLOCK // flags
	len@ // length
	len@ // bufsize
	off@ // offset
	pfdbe@ IOPageFrameEntryCache_PFN + @ PAGESHIFT << IDENTITYSPACE | // buffer
	fcb@ // fcb
	KERNELMODE // lastmode
	writefunc@ IODispatchWriteFunction ok! drop

	if (dontunbias@ ~~)
		// dontunbias will be 1 during something like truncation,
		// where the page frame is freed immediately after being
		// written out to disk. this avoids a redundant refcount bias,
		// which would be bad because interrupts will get disabled
		// for some cycles, twice, for no reason

		// no longer dirty, unbias the refcount
		pfdbe@ MmEvictablePageDereference drop
	end
end

fn IOCachePageGet { locked offset fcb -- pageframe pfdbe ok }
	if (DEBUGCHECKS)
		if (offset@ PAGEOFFSETMASK &)
			"IOCachePageGet: offset wasn't page-aligned\n" KeCrash
		end
	end

	0 ok!

	auto cacheblock

	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (locked@ ~~)
		cacheblock@ // cacheblock
		IOCacheInfoBlockLock ok!

		if (ok@)
			return
		end
	end

	auto filesize
	fcb@ IOFileControlBlock_SizeInBytes + @ filesize!

	if (DEBUGCHECKS)
		if (offset@ filesize@ >=)
			"IOCachePageGet: offset was beyond end of file\n" KeCrash
		end
	end

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	auto buckettail
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + 4 + buckettail!

	buckethead@@ pfdbe!

	while (pfdbe@)
		if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset@ ==)
			break
		end

		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
	end

	if (pfdbe@ ~~)
		// didn't find, need to allocate.
		// try without blocking first. if this fails,
		// try to grab a page from our own cache block.
		// only try again with CANBLOCK if there are none available.

		if (filesize@ offset@ - PAGESIZE <)
			// not a full page -- get zeroes because this might leak data otherwise

			MMEVICTFLAG_FAST // flags
			IOCacheEvictableFunctions // evictablefuncs
			ZEROMUST CACHEALLOC | // priority
			MmEvictablePageAlloc ok! drop pfdbe!
		end else
			// full page, get any random page that may or may not be zeroed

			MMEVICTFLAG_FAST // flags
			IOCacheEvictableFunctions // evictablefuncs
			FREEFIRST CACHEALLOC | // priority
			MmEvictablePageAlloc ok! drop pfdbe!
		end

		if (ok@)
			if (DEBUGCHECKS)
				if (ok@ STATUS_NO_MEMORY ~=)
					ok@ "IOCachePageGet: weird return value from MmEvictablePageAlloc (%i)\n" KeCrash
				end
			end

			// check each bucket from 0 to IOCACHEPAGEBUCKETS-1.
			// for each bucket, check from the least recently used end, backwards.
			// if a page with no references is found, yoink it.

			auto i
			0 i!

			while (i@ IOCACHEPAGEBUCKETS <)
				// get bucket tail
				cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + 4 + @ pfdbe!

				while (pfdbe@)
					if (pfdbe@ IOPageFrameEntryCache_References + @ 0 ==)
						// found one

						pfdbe@ MmEvictablePageReference drop
						cacheblock@ IOCacheInfoBlockDereference drop

						pfdbe@ // pfdbe
						cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + // buckethead
						IOCachePageRemove

						break
					end

					pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ pfdbe!
				end

				if (pfdbe@)
					break
				end

				1 i +=
			end

			0 ok!

			if (pfdbe@ ~~)
				// weren't able to find a reusable page. try to allocate again,
				// but this time we can block, without fear of deadlocking the
				// eviction thread. we also do not specify CACHEALLOC here, which
				// allows us to dip below the low watermark. normally, we try
				// not to do this in order to avoid waking the eviction thread
				// unnecessarily. here, it might happen, and we might block.

				if (filesize@ offset@ - PAGESIZE <)
					// not a full page -- get zeroes because this might leak data otherwise

					MMEVICTFLAG_FAST // flags
					IOCacheEvictableFunctions // evictablefuncs
					ZEROMUST CANBLOCK | // priority
					MmEvictablePageAlloc ok! drop pfdbe!
				end else
					// full page, get any random page that may or may not be zeroed

					MMEVICTFLAG_FAST // flags
					IOCacheEvictableFunctions // evictablefuncs
					FREEFIRST CANBLOCK | // priority
					MmEvictablePageAlloc ok! drop pfdbe!
				end

				if (ok@)
					if (locked@ ~~)
						cacheblock@ // cacheblock
						IOCacheInfoBlockUnlock
					end

					return
				end
			end
		end

		0 pfdbe@ IOPageFrameEntryCache_Flags + !
		offset@ pfdbe@ IOPageFrameEntryCache_OffsetInFile + !
		fcb@ pfdbe@ IOPageFrameEntryCache_FCB + !
		0 pfdbe@ IOPageFrameEntryCache_ModifiedPTE + !

		pfdbe@ // pfdbe
		buckethead@ // buckethead
		IOCachePageInsert

		// account for this new reference

		0 // oldcount
		pfdbe@ // pfdbe
		IOCachePageReferenceFunction

		// no need to ref the page -- it gets ref'd on allocation by MmEvictablePageAlloc
	end else
		// found the page, it was in the cache already!

		// remove from hash list so that it can be reinserted on the recently-used end

		if (pfdbe@ buckethead@@ ~=)
			pfdbe@ // pfdbe
			buckethead@ // buckethead
			IOCachePageRemove

			pfdbe@ // pfdbe
			buckethead@ // buckethead
			IOCachePageInsert
		end

		// ref it so it doesn't get evicted while caller is using it

		pfdbe@ MmEvictablePageReference drop
	end

	if (locked@ ~~)
		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlock
	end

	pfdbe@ IOPageFrameEntryCache_PFN + @ PAGESHIFT << IDENTITYSPACE | pageframe!
end

fn IOCacheDumpInfo { cacheblock -- }
	auto i
	0 i!

	while (i@ IOCACHEPAGEBUCKETS <)
		auto buckethead
		cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + buckethead!

		auto pfdbe
		buckethead@@ pfdbe!

		buckethead@ 4 + @ buckethead@@ i@ "%d h=%x t=%x: " Printf

		while (pfdbe@)
			pfdbe@ IOPageFrameEntryCache_References + @ "%d " Printf

			pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
		end

		"\n" Printf

		1 i +=
	end
end

fn IOCachePageRemove { pfdbe buckethead -- }
	// remove from hash list

	auto n
	pfdbe@ IOPageFrameEntryCache_NextCachePage + @ n!

	if (n@)
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no next means we were the tail
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ buckethead@ 4 + !
	end

	auto p
	pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ p!

	if (p@)
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ p@ IOPageFrameEntryCache_NextCachePage + !
	end else // no prev means we were the head
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ buckethead@!
	end
end

fn IOCachePageInsert { pfdbe buckethead -- }
	// insert into hash list on the recently-used end

	auto n
	buckethead@@ n!

	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	n@ pfdbe@ IOPageFrameEntryCache_NextCachePage + !

	if (n@)
		pfdbe@ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no head, set tail
		pfdbe@ buckethead@ 4 + !
	end

	pfdbe@ buckethead@!
end

fn (MmReferenceFunction) IOCachePageReferenceFunction { oldcount pfdbe -- }
	// keep track of a global refcount for the cache block.
	// this is done so that there's a fast way to tell whether
	// a file can be truncated.

	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	cacheblock@ // cacheblock
	IOCacheInfoBlockReference drop
end

fn (MmDereferenceFunction) IOCachePageDereferenceFunction { oldcount pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	cacheblock@ // cacheblock
	IOCacheInfoBlockDereference drop
end

fn (MmEvictionFunction) IOCachePageEvictionFunction { pfdbe -- evicted ok }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	cacheblock@ IOCacheInfoBlockTryLock ok!

	if (ok@ ~~)
		// failed to lock -- don't wait.
		// return so that the eviction thread can
		// immediately try the next page.

		0 ok!
		0 evicted!

		return
	end

	// we come in here in IPLDPC for synchronization reasons, but now
	// that we have the cacheblock locked, we can lower IPL. we just
	// have to remember to raise it again when we leave!

	IPLLOW KeIPLLower

	0 ok!

	if (DEBUGCHECKS)
		if (pfdbe@ MmPageFrameEntryEvictable_References + @ 0 ==)
			"IOCachePageEvictionFunction: refcount == 0\n" KeCrash
		end
	end

	if (pfdbe@ MmPageFrameEntryEvictable_References + @ 1 >)
		// no longer a candidate for eviction!

		cacheblock@ IOCacheInfoBlockUnlock

		0 evicted!

		IPLDPC KeIPLRaise drop

		return
	end

	if (DEBUGCHECKS)
		if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
			// we shouldn't be trying to evict a dirty page frame
			// until the dirty page writer thread it is written out
			// and dereferenced...

			"IOCachePageEvictionFunction: tried to evict a dirty page frame\n" KeCrash
		end
	end

	auto offset
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset!

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	// remove from hash list

	pfdbe@ // pfdbe
	buckethead@ // buckethead
	IOCachePageRemove

	// earlier, the eviction thread incremented this refcount
	// by ref'ing this page frame. undo that.
	cacheblock@ IOCacheInfoBlockDereference drop

	cacheblock@ IOCacheInfoBlockUnlock

	1 evicted!

	IPLDPC KeIPLRaise drop
end

fn (MmModifyFunction) IOCachePageModifyFunction { pfdbe -- ok }
	// mark a page modified and insert it on the modified page list if necessary

	0 ok!

	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageModify: no cacheblock on FCB\n" KeCrash
		end
	end

	auto rs
	HALCPUInterruptDisable rs!

	if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
		rs@ HALCPUInterruptRestore

		return
	end

	// bias the refcount so that it doesn't get evicted while dirty.
	// this gets undone when it is written out.

	pfdbe@ MmEvictablePageReference drop

	pfdbe@ IOCachePageInsertModified

	IOCACHEPAGEFLAG_DIRTY pfdbe@ IOPageFrameEntryCache_Flags + |=

	// mark valid: the page must either already be valid, and only be partially modified,
	// or be invalid and fully overwritten (in which case, it is now valid). caller guarantees this.
	IOCACHEPAGEFLAG_VALID pfdbe@ IOPageFrameEntryCache_Flags + |=

	// will be decremented when written out
	1 cacheblock@ IOCacheInfoBlock_ModifiedPages + +=

	rs@ HALCPUInterruptRestore
end

fn IOCachePageRead { flags offset fcb -- pageframe pfdbe ok }
	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageRead: attempt to perform cached page read from noncached file\n" KeCrash
		end
	end

	cacheblock@ IOCacheInfoBlockLock ok!

	if (ok@)
		return
	end

	1 // locked
	offset@ // offset
	fcb@ // fcb
	IOCachePageGet ok! pfdbe! pageframe!

	if (ok@)
		cacheblock@ IOCacheInfoBlockUnlock

		return
	end

	if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_VALID & ~~)
		// this cache page is invalid and needs to be read in

		auto readfunc
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

		if (readfunc@ ~~)
			// XXX should this not just cause a crash? honestly

			pfdbe@ MmEvictablePageDereference drop

			cacheblock@ IOCacheInfoBlockUnlock

			STATUS_IO_NOT_SUPPORTED ok!

			return
		end

		// perform the read operation

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ OSACCESSFLAG_BLOCK | // flags
		PAGESIZE // length
		PAGESIZE // bufsize
		offset@ // offset
		pageframe@ // buffer
		fcb@ // fcb
		KERNELMODE // lastmode
		readfunc@ IODispatchReadFunction ok! drop

		if (ok@)
			// read failed

			pfdbe@ MmEvictablePageDereference drop

			cacheblock@ IOCacheInfoBlockUnlock

			return
		end

		// read succeeded, page is now valid

		IOCACHEPAGEFLAG_VALID pfdbe@ IOPageFrameEntryCache_Flags + |=
	end

	cacheblock@ IOCacheInfoBlockUnlock
end

fn IOCacheFileWrite { flags length bufsize offset buffer fcb -- byteswritten ok }
	auto pfdbe
	auto pageframe

	0 ok!

	0 byteswritten!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCacheFileWrite: attempt to write file with no cacheblock\n" KeCrash
		end
	end

	cacheblock@ // cacheblock
	IOCacheInfoBlockTryReference ok! drop

	if (ok@)
		return
	end

	auto bytesize
	fcb@ IOFileControlBlock_SizeInBytes + @ bytesize!

	auto growfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Grow + @ growfunc!

	if (growfunc@ ~~)
		// driver provides no way to grow this file

		if (offset@ bytesize@ >=)
			cacheblock@ // cacheblock
			IOCacheInfoBlockDereference drop

			STATUS_IO_END_OF_DISK ok!

			return
		end

		bytesize@ offset@ -
		length@
		min length!
	end else
		if (offset@ PAGENUMBERMASK >=)
			// prevent underflow

			cacheblock@ // cacheblock
			IOCacheInfoBlockDereference drop

			STATUS_IO_END_OF_FILE ok!

			return
		end

		PAGENUMBERMASK offset@ -
		length@
		min length!
	end

	while (byteswritten@ length@ <)
		if (byteswritten@ bufsize@ ==)
			cacheblock@ // cacheblock
			IOCacheInfoBlockDereference drop

			STATUS_BUFFER_MAXIMUM ok!

			return
		end

		if (DEBUGCHECKS)
			if (byteswritten@ bufsize@ >)
				"IOCacheFileWrite: byteswritten > bufsize\n" KeCrash
			end
		end

		auto pageno
		offset@ PAGENUMBERMASK & pageno!

		auto pageoff
		offset@ PAGEOFFSETMASK & pageoff!

		auto m

		length@ byteswritten@ -
		PAGESIZE pageoff@ -
		min
		bufsize@ byteswritten@ -
		min m!

		if (DEBUGCHECKS)
			// just in case im dumb

			if (m@ ~~)
				"IOCacheFileWrite: m == 0\n" KeCrash
			end
		end

		if (growfunc@)
			fcb@ IOFileControlBlock_SizeInBytes + @ bytesize!

			if (offset@ m@ + bytesize@ >)
				m@ // length
				offset@ // offset
				fcb@ // fcb
				growfunc@ IODispatchGrowFunction ok!

				if (ok@)
					cacheblock@ // cacheblock
					IOCacheInfoBlockDereference drop

					return
				end
			end
		end

		if (m@ PAGESIZE ==)
			// writing a full page -- no need to read something we're about to overwrite

			0 // locked
			pageno@ // offset
			fcb@ // fcb
			IOCachePageGet ok! pfdbe! pageframe!

			if (ok@)
				cacheblock@ // cacheblock
				IOCacheInfoBlockDereference drop

				return
			end
		end else
			// writing a partial page, may need to read the rest of the page

			flags@ // flags
			pageno@ // offset
			fcb@ // fcb
			IOCachePageRead ok! pfdbe! pageframe!

			if (ok@)
				cacheblock@ // cacheblock
				IOCacheInfoBlockDereference drop

				return
			end
		end

		pageframe@ pageoff@ + // dest
		buffer@ // src
		m@ // size
		memcpy

		pfdbe@ IOCachePageModifyFunction ok!

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "IOCacheFileWrite: failed to mark page frame modified (%i)\n" KeCrash
			end
		end

		pfdbe@ MmEvictablePageDereference drop

		m@ buffer +=
		m@ byteswritten +=
		m@ offset +=
	end

	cacheblock@ // cacheblock
	IOCacheInfoBlockDereference drop
end

fn IOCacheFileRead { flags length bufsize offset buffer fcb -- bytesread ok }
	auto pfdbe
	auto pageframe

	0 ok!

	0 bytesread!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCacheFileRead: attempt to read file with no cacheblock\n" KeCrash
		end
	end

	cacheblock@ // cacheblock
	IOCacheInfoBlockTryReference ok! drop

	if (ok@)
		return
	end

	auto bytesize
	fcb@ IOFileControlBlock_SizeInBytes + @ bytesize!

	if (offset@ bytesize@ >=)
		cacheblock@ // cacheblock
		IOCacheInfoBlockDereference drop

		return
	end

	bytesize@ offset@ -
	length@
	min length!

	while (bytesread@ length@ <)
		if (bytesread@ bufsize@ ==)
			cacheblock@ // cacheblock
			IOCacheInfoBlockDereference drop

			STATUS_BUFFER_MAXIMUM ok!

			return
		end

		if (DEBUGCHECKS)
			if (bytesread@ bufsize@ >)
				"IOCacheFileRead: bytesread > bufsize\n" KeCrash
			end
		end

		auto pageno
		offset@ PAGENUMBERMASK & pageno!

		auto pageoff
		offset@ PAGEOFFSETMASK & pageoff!

		auto m

		length@ bytesread@ -
		PAGESIZE pageoff@ -
		min
		bufsize@ bytesread@ -
		min m!

		if (DEBUGCHECKS)
			if (m@ ~~)
				"IOCacheFileRead: m == 0\n" KeCrash
			end
		end

		flags@ // flags
		pageno@ // offset
		fcb@ // fcb
		IOCachePageRead ok! pfdbe! pageframe!

		if (ok@)
			cacheblock@ // cacheblock
			IOCacheInfoBlockDereference drop

			return
		end

		buffer@ // dest
		pageframe@ pageoff@ + // src
		m@ // size
		memcpy

		pfdbe@ MmEvictablePageDereference drop

		m@ buffer +=
		m@ bytesread +=
		m@ offset +=
	end

	cacheblock@ // cacheblock
	IOCacheInfoBlockDereference drop
end

fn IOCacheInitialize { fcb -- cacheblock ok }
	// initialize caching for an FCB

	IOCacheInfoBlockCreate ok! cacheblock!

	if (ok@)
		// creation failed

		return
	end

	if (DEBUGCHECKS)
		if (fcb@ IOFileControlBlock_CacheInfoBlock + @)
			"IOCacheInitialize: FCB already had a cache info block\n" KeCrash
		end
	end

	cacheblock@ fcb@ IOFileControlBlock_CacheInfoBlock + !
end
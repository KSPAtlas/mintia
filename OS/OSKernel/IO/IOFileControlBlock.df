#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOFileControlBlockCreate { dispatchtable devobj filetype flags -- fcb ok }
	IOFileControlBlock_SIZEOF // bytes
	'IOFC' // tag
	MmAllocWithTag ok! fcb!

	if (ok@)
		return
	end

	devobj@ fcb@ IOFileControlBlock_DeviceObject + !
	filetype@ fcb@ IOFileControlBlock_FileType + !

	flags@ fcb@ IOFileControlBlock_Flags + !
	0 fcb@ IOFileControlBlock_CacheInfoBlock + !
	0 fcb@ IOFileControlBlock_References + !
	0 fcb@ IOFileControlBlock_SizeInBytes + !
	dispatchtable@ fcb@ IOFileControlBlock_DispatchTable + !
	0 fcb@ IOFileControlBlock_Busy + !
	0 fcb@ IOFileControlBlock_ParseCount + !

	"FCBMutex" // name
	KERNELMODE // mode
	fcb@ IOFileControlBlock_Mutex + // mutex
	KeMutexInitialize ok!

	if (ok@)
		"IOFileControlBlockCreate: mutex initialization failed\n" KeCrash
	end

	"FCBIOMutex" // name
	KERNELMODE // mode
	fcb@ IOFileControlBlock_IOMutex + // mutex
	KeMutexInitialize ok!

	if (ok@)
		"IOFileControlBlockCreate: IO mutex initialization failed\n" KeCrash
	end
end

fn IOFileControlBlockDelete { fcb -- }
	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (cacheblock@)
		"IOFileControlBlockDelete: TODO delete cache block\n" KeCrash
	end

	fcb@ MmFree
end

fn IOFileControlBlockLock { fcb -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	fcb@ IOFileControlBlock_Mutex + // object
	KeThreadWaitForObject ok!
end

fn IOFileControlBlockUnlock { fcb -- }
	fcb@ IOFileControlBlock_Mutex + KeMutexRelease drop
end

fn IOFileControlBlockLockIO { fcb -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	fcb@ IOFileControlBlock_IOMutex + // object
	KeThreadWaitForObject ok!
end

fn IOFileControlBlockUnlockIO { fcb -- }
	fcb@ IOFileControlBlock_IOMutex + KeMutexRelease drop
end

fn IOFileControlBlockReference { fcb -- oldcount }
	// should be called by filesystem driver in its parse method, if needed.

	auto rs
	HALCPUInterruptDisable rs!

	fcb@ IOFileControlBlock_References + @ oldcount!

	oldcount@ 1 + fcb@ IOFileControlBlock_References + !

	rs@ HALCPUInterruptRestore
end

fn IOFileControlBlockDereference { fcb -- oldcount }
	// should be called by filesystem driver in its delete method, if needed.

	auto rs
	HALCPUInterruptDisable rs!

	fcb@ IOFileControlBlock_References + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"IOFileControlBlockDereference: refcount underflow\n" KeCrash
		end
	end

	oldcount@ 1 - fcb@ IOFileControlBlock_References + !

	rs@ HALCPUInterruptRestore
end
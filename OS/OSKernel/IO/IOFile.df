#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOFileCreateObject { flags owninguser fcb -- fileobject ok }
	// just shorthand for creating a file object, doesn't open it.
	// also does NOT ref the FCB -- caller must do that.

	0 // name
	0 // flags
	ACCESS_OWNER_ALL // permissions
	owninguser@ // owninguser
	IOFile_SIZEOF // bodysize
	IOFileTypeObject@ // type
	ObObjectCreate ok! fileobject!

	fcb@   fileobject@ IOFile_FileControlBlock + !
	0      fileobject@ IOFile_Offset + !
	flags@ fileobject@ IOFile_Flags + !
end

fn (ObTypeOpenFunction) IOFileOpen { object process -- ok }
	auto openfunc

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DEVICE ==)
		fcb@ IOFileControlBlock_DeviceObject + @ IODevice_Driver + @ IODriver_DispatchTable + @ IODispatchTable_Open + @ openfunc!

		if (openfunc@)
			object@ // object
			openfunc@ IODispatchOpenFunction ok!
		end else
			0 ok!
		end

		return
	end else
		// dispatch to filesystem driver

		"IOFileOpen: NYI\n" KeCrash
	end
end

fn (ObTypeCloseFunction) IOFileClose { object process -- }
	auto ok

	auto closefunc

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DEVICE ==)
		fcb@ IOFileControlBlock_DeviceObject + @ IODevice_Driver + @ IODriver_DispatchTable + @ IODispatchTable_Close + @ closefunc!

		if (closefunc@)
			object@ // object
			closefunc@ IODispatchOpenFunction ok!

			if (DEBUGCHECKS)
				if (ok@)
					ok@ "IOFileClose: failed to close (%i)\n" KeCrash
				end
			end
		end else
			0 ok!
		end

		return
	end else
		// dispatch to filesystem driver

		"IOFileClose: NYI\n" KeCrash
	end
end

fn (ObTypeDeleteFunction) IOFileDelete { object -- }
	auto ok

	auto deletefunc

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DEVICE ==)
		fcb@ IOFileControlBlock_DeviceObject + @ IODevice_Driver + @ IODriver_DispatchTable + @ IODispatchTable_DeleteObject + @ deletefunc!

		if (deletefunc@)
			object@ // object
			deletefunc@ IODispatchDeleteFunction ok!

			if (DEBUGCHECKS)
				if (ok@)
					ok@ "IOFileDelete: failed to delete (%i)\n" KeCrash
				end
			end
		end else
			0 ok!
		end

		return
	end else
		// dispatch to filesystem driver

		"IOFileDelete: NYI\n" KeCrash
	end
end

fn IOFileControlBlockCreate { dispatchtable devobj filetype flags -- fcb ok }
	IOFileControlBlock_SIZEOF // bytes
	'IOFC' // tag
	MmAllocWithTag ok! fcb!

	if (ok@)
		return
	end

	devobj@ fcb@ IOFileControlBlock_DeviceObject + !
	filetype@ fcb@ IOFileControlBlock_FileType + !

	flags@ fcb@ IOFileControlBlock_Flags + !
	0 fcb@ IOFileControlBlock_CacheInfoBlock + !
	1 fcb@ IOFileControlBlock_References + !
	dispatchtable@ fcb@ IOFileControlBlock_DispatchTable + !
end

fn IOFileControlBlockReference { fcb -- oldcount }
	// should be called by filesystem driver in its parse method, if needed

	auto rs
	HALCPUInterruptDisable rs!

	fcb@ IOFileControlBlock_References + @ oldcount!

	oldcount@ 1 + fcb@ IOFileControlBlock_References + !

	rs@ HALCPUInterruptRestore
end

fn IOFileControlBlockDereference { fcb -- oldcount }
	// should be called by filesystem driver in its delete method, if needed

	auto rs
	HALCPUInterruptDisable rs!

	fcb@ IOFileControlBlock_References + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"IOFileControlBlockDereference: refcount underflow\n" KeCrash
		end
	end

	oldcount@ 1 - fcb@ IOFileControlBlock_References + !

	rs@ HALCPUInterruptRestore

	if (oldcount@ 1 ==)
		// just lowered the refcount to 0, deallocate

		fcb@ MmFree
	end
end
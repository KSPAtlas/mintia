#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOFileRead { flags length buffer filehandle -- bytesread ok }
	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	flags@ // flags
	length@ // length
	buffer@ // buffer
	fileobject@ // fileobject
	KeProcessCurrent // process
	IOFileReadProcess ok! bytesread!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileReadProcess { flags length buffer fileobject process -- bytesread ok }
	if (process@ PsSystemProcess@ ==)
		0 process!
	end

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IOFileReadProcess: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IOFileReadProcess: file object had no dispatch table\n" KeCrash
		end
	end

	auto readfunc
	dispatchtable@ IODispatchTable_Read + @ readfunc!

	if (readfunc@ ~~)
		STATUS_IO_NOT_SUPPORTED ok!

		return
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	0 bytesread!

	if (process@ ~~)
		// no process provided to read into. therefore, we must be reading directly into
		// system space.

		if (buffer@ MMLOWESTSYSTEMADDRESS <)
			"IOFileReadProcess: buffer was not in system space\n" KeCrash
		end

		if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
			// always bypass cache for character devices -- call directly into driver.

			if (DEBUGCHECKS)
				if (cacheblock@)
					"IOFileReadProcess: file was character device, but is cached?\n" KeCrash
				end
			end

			flags@ // flags
			length@ // length
			length@ // bufsize (same as length since system is trusted)
			fileobject@ IOFile_Offset + @ // offset
			buffer@ // buffer
			fileobject@ // object
			KERNELMODE // lastmode (kernel mode assumed, since this is a system space read)
			readfunc@ IODispatchReadFunction ok! bytesread!
		end else
			"IOFileReadProcess: TODO potentially cached file/block device reads\n" KeCrash
		end
	end else
		// translate and lock each buffer page into memory.
		// (this may incur page fault logic (but never a page fault exception)).
		// for each buffer page, read at most 4096 bytes from the file
		// into the identity-mapped page frame.

		// buffer must not be in system space.

		if (buffer@ MMHIGHESTUSERADDRESS >)
			STATUS_FORBIDDEN_OPERATION ok!

			return
		end

		"IOFileReadProcess: TODO userspace reads\n" KeCrash
	end

	auto rs
	HALCPUInterruptDisable rs!

	bytesread@ fileobject@ IOFile_Offset + +=

	rs@ HALCPUInterruptRestore
end
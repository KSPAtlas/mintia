#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOFileSeek { offset handle mode -- ok }
	if (mode@ 0 ==)
		STATUS_INVALID_ARGUMENT ok!

		return
	end elseif (mode@ OSSEEK_END >)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	auto fileobject

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! drop

	if (ok@)
		return
	end

	offset@ // offset
	fileobject@ // fileobject
	mode@ // mode
	IOFileSeekObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileSeekObject { offset fileobject mode -- ok }
	0 ok!

	auto curoffset
	fileobject@ IOFile_Offset + @ curoffset!

	if (mode@ OSSEEK_SET ==)
		offset@ curoffset!
	end elseif (mode@ OSSEEK_CUR ==)
		curoffset@ offset@ + curoffset!
	end elseif (mode@ OSSEEK_END ==)
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_SizeInBytes + @ offset@ + curoffset!
	end

	curoffset@ fileobject@ IOFile_Offset + !
end

fn IOFileRead { flags length buffer filehandle -- bytesread ok }
	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	flags@ // flags
	length@ // length
	buffer@ // buffer
	fileobject@ // fileobject
	KeProcessCurrent // process
	IOFileReadProcess ok! bytesread!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileReadProcess { flags length buffer fileobject process -- bytesread ok }
	if (process@ PsSystemProcess@ ==)
		0 process!
	end

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IOFileReadProcess: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IOFileReadProcess: file object had no dispatch table\n" KeCrash
		end
	end

	auto readfunc
	dispatchtable@ IODispatchTable_Read + @ readfunc!

	if (readfunc@ ~~)
		STATUS_IO_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto fileflags
	fileobject@ IOFile_Flags + @ fileflags!

	0 bytesread!

	if (process@ ~~)
		// no process provided to read into. therefore, we must be reading directly into
		// system space.

		if (buffer@ MMLOWESTSYSTEMADDRESS <)
			"IOFileReadProcess: buffer was not in system space\n" KeCrash
		end

		if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
			// always bypass cache for character devices -- call directly into driver.

			if (DEBUGCHECKS)
				if (cacheblock@)
					"IOFileReadProcess: file was character device, but is cached?\n" KeCrash
				end
			end

			flags@ // flags
			length@ // length
			length@ // bufsize (same as length since system is trusted)
			fileobject@ IOFile_Offset + @ // offset
			buffer@ // buffer
			fcb@ // fcb
			KERNELMODE // lastmode (kernel mode assumed, since this is a system space read)
			readfunc@ IODispatchReadFunction ok! bytesread!

			return
		end

		if (cacheblock@ ~~)
			fileflags@ OSFILEFLAG_NOCACHE & ~~ // wantcaching
			fcb@ // fcb
			IOFileCacheCheck ok! cacheblock!

			if (ok@)
				return
			end
		end

		if (cacheblock@ ~~)
			// no caching -- call directly into driver.

			flags@ // flags
			length@ // length
			length@ // bufsize (same as length since system is trusted)
			fileobject@ IOFile_Offset + @ // offset
			buffer@ // buffer
			fcb@ // fcb
			KERNELMODE // lastmode (kernel mode assumed, since this is a system space read)
			readfunc@ IODispatchReadFunction ok! bytesread!

			// the FCB is still locked since this read was uncached

			fcb@ IOFileControlBlockUnlock
		end else
			// caching -- call into cache read function.

			flags@ // flags
			length@ // length
			length@ // bufsize (same as length since system is trusted)
			fileobject@ IOFile_Offset + @ // offset
			buffer@ // buffer
			fcb@ // fcb
			KERNELMODE // lastmode (kernel mode assumed, since this is a system space read)
			IOCacheFileRead ok! bytesread!
		end
	end else
		// translate and lock each buffer page into memory.
		// (this may incur page fault logic (but never a page fault exception)).
		// for each buffer page, read at most 4096 bytes from the file
		// into the identity-mapped page frame.

		// buffer must not be in system space.

		if (buffer@ MMHIGHESTUSERADDRESS >)
			STATUS_FORBIDDEN_OPERATION ok!

			return
		end

		"IOFileReadProcess: TODO userspace reads\n" KeCrash
	end

	auto rs
	HALCPUInterruptDisable rs!

	bytesread@ fileobject@ IOFile_Offset + +=

	rs@ HALCPUInterruptRestore
end

fn IOFileCacheCheck { wantcaching fcb -- cacheblock ok }
	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (wantcaching@)
		if (cacheblock@ ~~)
			// still no cache block, plus we want there to be one.
			// therefore, initiate caching

			fcb@ // fcb
			IOCacheInitialize ok! cacheblock!

			if (ok@)
				// failed to initialize caching, do this I/O operation
				// uncached and try again later...

				0 cacheblock!
			end
		end
	end

	if (cacheblock@)
		// may or may not have wanted caching, but are getting it regardless.
		// unlock the FCB

		fcb@ IOFileControlBlockUnlock
	end

	// if we didn't want caching, and there was no cache block, the FCB remains locked
	// for the duration of the operation.
end
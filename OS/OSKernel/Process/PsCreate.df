#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALDebug.h"

fn PsProcessCreate { permissions name -- processhandle ok }
	auto current
	KeProcessCurrent current!

	auto process

	name@ // name
	0 // flags
	permissions@ // permissions
	SeUserCurrentGet // owninguser
	PsProcess_SIZEOF // bodysize
	PsProcessObjectType@ // type
	ObObjectCreate ok! process!

	if (ok@)
		return
	end

	current@ PsProcess_OwningUser + @ process@ PsProcess_OwningUser + !

	auto quotablock
	current@ PsProcess_QuotaBlock + @ quotablock!

	quotablock@ MmQuotaBlockReference
	quotablock@ process@ PsProcess_QuotaBlock + !

	auto handletable

	process@ // chargedprocess
	OBHANDLEENTRYSIZELOG // entrysizelog
	ExHandleTableCreate ok! handletable!

	if (ok@)
		quotablock@ MmQuotaBlockDereference

		process@ ObObjectDeallocate

		return
	end

	handletable@ process@ PsProcess_HandleTable + !

	name@ process@ KeProcessInitialize ok!

	if (ok@)
		quotablock@ MmQuotaBlockDereference

		0 handletable@ ExHandleTableDelete

		process@ ObObjectDeallocate

		return
	end

	// put it on the global process list

	auto rs
	HALCPUInterruptDisable rs!

	auto h

	PsProcessListHead@ h!

	if (h@)
		process@ h@ PsProcess_GlobalListPrev + !
		h@ process@ PsProcess_GlobalListNext + !
	end

	process@ PsProcessListHead!

	rs@ HALCPUInterruptRestore

	permissions@ 6 >> // permissions. open with maximum permissions that the owner gave themselves.
	process@ // process
	ObObjectOpen ok! processhandle!

	if (ok@)
		// just dereference and let PsProcessObjectDelete take care of the cleanup

		process@ ObObjectDereferenceByPointer drop

		return
	end
end

fn PsThreadCreate { context1 context2 startfunc permissions name processhandle processptr -- threadhandle ok }
	if (processhandle@)
		if (processptr@)
			STATUS_INVALID_ARGUMENT ok!

			return
		end

		// use threadhandle to contain access bits here

		PsProcessObjectType@ // type
		processhandle@ // handle
		ObObjectReferenceByHandle ok! processptr! threadhandle!

		if (ok@)
			return
		end

		threadhandle@ ACCESS_WRITE SeCheckAccess ok!

		if (ok@)
			processptr@ ObObjectDereferenceByPointer drop

			return
		end
	end else
		if (processptr@ ~~)
			STATUS_INVALID_ARGUMENT ok!

			return
		end

		processptr@ ObObjectReferenceByPointer drop
	end

	auto threadptr

	name@ // name
	0 // flags
	permissions@ // permissions
	SeUserCurrentGet // owninguser
	PsThread_SIZEOF // bodysize
	PsThreadObjectType@ // type
	ObObjectCreate ok! threadptr!

	if (ok@)
		if (processhandle@)
			processptr@ ObObjectDereferenceByPointer drop
		end

		return
	end

	auto kstack
	MmKernelStackAlloc ok! kstack!

	if (ok@)
		if (processhandle@)
			processptr@ ObObjectDereferenceByPointer drop
		end

		threadptr@ ObObjectDeallocate

		return
	end

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	processptr@ // process
	kstack@ // kstack
	name@ // name
	threadptr@ // thread
	KeThreadInitialize ok!

	if (ok@)
		if (processhandle@)
			processptr@ ObObjectDereferenceByPointer drop
		end

		kstack@ MmKernelStackFree

		threadptr@ KeThreadUninitialize

		threadptr@ ObObjectDeallocate

		return
	end

	permissions@ 6 >> // permissions. open with maximum permissions that the owner gave themselves.
	threadptr@ // thread
	ObObjectOpen ok! threadhandle!

	if (ok@)
		if (processhandle@)
			processptr@ ObObjectDereferenceByPointer drop
		end

		// just dereference and let PsThreadObjectDelete take care of the cleanup

		threadptr@ ObObjectDereferenceByPointer drop

		return
	end

	// bias reference count: this gets decremented when the thread is reaped.
	// note that the associated process object is also left referenced.
	// the process is dereferenced when the thread object is deleted.

	threadptr@ ObObjectReferenceByPointer drop

	QUEUEBACK threadptr@ KeThreadReady
end
#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALDebug.h"

fn PsProcessCreate { sectionobject inherithandles owninguser parentprocess permissions name -- processhandle ok }
	auto initial
	0 initial!

	if (parentprocess@ ~~)
		if (KeProcessCurrent KeProcessIdleProcess ~=)
			"PsProcessCreate: no parent process specified but not the idle process\n" KeCrash
		end

		KeProcessIdleProcess parentprocess!

		1 initial!
	end

	auto process

	name@ // name
	0 // flags
	permissions@ // permissions
	owninguser@ // owninguser
	PsProcess_SIZEOF // bodysize
	PsProcessObjectType@ // type
	ObObjectCreate ok! process!

	if (ok@)
		return
	end

	owninguser@ process@ PsProcess_OwningUser + !

	auto quotablock
	parentprocess@ PsProcess_QuotaBlock + @ quotablock!

	quotablock@ MmQuotaBlockReference
	quotablock@ process@ PsProcess_QuotaBlock + !

	auto handletable

	if (initial@ ~~)
		if (inherithandles@)
			pointerof ObHandleInheritFunction // func
			parentprocess@ PsProcess_HandleTable + @ // handletablesrc
			process@ // chargedprocess
			ExHandleTableDuplicate ok! handletable!

			if (ok@)
				quotablock@ MmQuotaBlockDereference

				process@ ObObjectDeallocate

				return
			end
		end else
			process@ // chargedprocess
			OBHANDLEENTRYSIZELOG // entrysizelog
			ExHandleTableCreate ok! handletable!

			if (ok@)
				quotablock@ MmQuotaBlockDereference

				process@ ObObjectDeallocate

				return
			end
		end
	end else
		// save some heap and reuse the idle process handle table
		parentprocess@ PsProcess_HandleTable + @ handletable!
	end

	handletable@ process@ PsProcess_HandleTable + !

	auto pid

	// XXX this may be VERY racey,
	// should probably take a mutex to lock out
	// any operations that take a process's PID
	// until this process is fully initialized.

	process@ // entryvalue
	PsProcessTable@ // handletable
	0 // locked
	ExHandleCreate ok! drop pid!

	if (ok@)
		quotablock@ MmQuotaBlockDereference

		if (initial@ ~~)
			0 handletable@ ExHandleTableDelete
		end

		process@ ObObjectDeallocate

		return
	end

	pid@ process@ PsProcess_PID + !

	// put it on the global process list

	auto rs
	HALCPUInterruptDisable rs!

	auto h

	PsProcessListHead@ h!

	if (h@)
		process@ h@ PsProcess_GlobalListPrev + !
		h@ process@ PsProcess_GlobalListNext + !
	end

	process@ PsProcessListHead!

	rs@ HALCPUInterruptRestore

	name@ // name
	pid@ // asid
	process@ // process
	KeProcessInitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			"PsProcessCreate: failed to initialize process\n" KeCrash
		end
	end

	if (initial@ ~~)
		sectionobject@ // sectionobject
		process@ // process
		MmProcessInitialize ok!

		if (ok@)
			// just dereference and let PsProcessObjectDelete take care of the cleanup

			process@ ObObjectDereferenceByPointer drop

			return
		end
	end

	1 // nocheck
	ACCESS_ALL // permissions
	process@ // process
	ObObjectOpen ok! processhandle!

	if (ok@)
		// just dereference and let PsProcessObjectDelete take care of the cleanup

		process@ ObObjectDereferenceByPointer drop

		return
	end
end

fn PsThreadCreate { context1 context2 startfunc permissions name processhandle processptr -- threadhandle ok }
	if (processhandle@)
		if (processptr@)
			STATUS_INVALID_ARGUMENT ok!

			return
		end

		// use threadhandle to contain access bits here

		PsProcessObjectType@ // type
		processhandle@ // handle
		ObObjectReferenceByHandle ok! processptr! threadhandle!

		if (ok@)
			return
		end

		threadhandle@ ACCESS_WRITE SeCheckAccess ok!

		if (ok@)
			processptr@ ObObjectDereferenceByPointer drop

			return
		end
	end else
		if (processptr@ ~~)
			STATUS_INVALID_ARGUMENT ok!

			return
		end

		processptr@ ObObjectReferenceByPointer drop
	end

	auto threadptr

	name@ // name
	0 // flags
	permissions@ // permissions
	SeUserCurrentGet // owninguser
	PsThread_SIZEOF // bodysize
	PsThreadObjectType@ // type
	ObObjectCreate ok! threadptr!

	if (ok@)
		processptr@ ObObjectDereferenceByPointer drop

		return
	end

	auto kstack
	MmKernelStackAlloc ok! kstack!

	if (ok@)
		processptr@ ObObjectDereferenceByPointer drop

		threadptr@ ObObjectDeallocate

		return
	end

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	processptr@ // process
	kstack@ // kstack
	name@ // name
	threadptr@ // thread
	KeThreadInitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			"PsThreadCreate: failed to initialize thread\n" KeCrash
		end
	end

	if (startfunc@ pointerof PsThreadUserEntry ==)
		threadptr@ MmThreadInitialize ok!

		if (ok@)
			processptr@ ObObjectDereferenceByPointer drop

			kstack@ MmKernelStackFree

			threadptr@ KeThreadUninitialize

			threadptr@ ObObjectDeallocate

			return
		end
	end

	1 // nocheck
	ACCESS_ALL // permissions
	threadptr@ // thread
	ObObjectOpen ok! threadhandle!

	if (ok@)
		processptr@ ObObjectDereferenceByPointer drop

		threadptr@ MmThreadUninitialize threadhandle!

		if (DEBUGCHECKS)
			if (threadhandle@)
				"PsThreadCreate: failed to uninitialize thread\n" KeCrash
			end
		end

		// just dereference and let PsThreadObjectDelete take care of the cleanup

		threadptr@ ObObjectDereferenceByPointer drop

		return
	end

	// bias reference count: this gets decremented when the thread is reaped.
	// note that the associated process object is also left referenced.
	// the process is dereferenced when the thread object is deleted.

	threadptr@ ObObjectReferenceByPointer drop

	QUEUEBACK threadptr@ KeThreadReady
end
#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"

#include "<inc>/Kernel.h"

#include "<inc>/HALInterrupt.h"

// XXX this global will NOT work out well if we ever go multiprocessor.
// though, neither will most things that we're doing.
var KeIPLCurrent IPLHIGH
public KeIPLCurrent

fn KeIPLCurrentGet { -- ipl }
	KeIPLCurrent@ ipl!
end

fn KeIPLSet { old ipl -- }
	// only call into the HAL if hardware interrupt level changed.
	// no need to call in for software interrupt levels IPLLOW-IPLDPC.
	// XXX ...or is there?

	if (ipl@ IPLDPC >)
		ipl@ HALPlatformIPLSet
	end elseif (old@ IPLDPC >)
		ipl@ HALPlatformIPLSet
	end

	ipl@ KeIPLCurrent!
end

fn KeIPLRaise { newipl -- oldipl }
	auto rs
	HALCPUInterruptDisable rs!

	KeIPLCurrent@ oldipl!

	if (newipl@ oldipl@ ==)
		rs@ HALCPUInterruptRestore
		return
	end

	if (newipl@ oldipl@ <)
		[newipl@]HALIPLNames@ [oldipl@]HALIPLNames@ "IPL not greater or equal (old=%s new=%s)\n" KeCrash
	end

	oldipl@ newipl@ KeIPLSet

	rs@ HALCPUInterruptRestore
end

fn KeIPLLower { newipl -- }
	auto rs
	HALCPUInterruptDisable rs!

	auto oldipl
	KeIPLCurrent@ oldipl!

	if (newipl@ oldipl@ ==)
		rs@ HALCPUInterruptRestore

		return
	end

	if (newipl@ oldipl@ >)
		[newipl@]HALIPLNames@ [oldipl@]HALIPLNames@ "IPL not less or equal (old=%s new=%s)\n" KeCrash
	end

	if (newipl@ IPLDPC >=)
		oldipl@ newipl@ KeIPLSet

		rs@ HALCPUInterruptRestore

		return
	end

	if (oldipl@ IPLAPC >)
		// the new IPL isn't >=IPLDPC, and the old IPL was >IPLAPC.
		// this means that we've dropped below IPLDPC and may have some DPCs
		// to process.

		oldipl@ IPLDPC KeIPLSet

		IPLDPC oldipl!

		rs@ KeDPCDispatchQueue

		rs@ HALCPUInterruptRestore

		if (KeThreadNext@)
			KeThreadNextSwitch
		end

		HALCPUInterruptDisable rs!
	end

	oldipl@ IPLAPC KeIPLSet

	if (newipl@ IPLAPC ==)
		rs@ HALCPUInterruptRestore

		return
	end

	// we're dropping below IPLAPC. deal with processing APCs.

	if (KeThreadCurrent@)
		rs@ HALCPUInterruptRestore

		0 KERNELMODE KeAPCDispatchQueue

		HALCPUInterruptDisable rs!
	end

	IPLAPC newipl@ KeIPLSet

	rs@ HALCPUInterruptRestore
end

externptr HALInterruptStackTop

var KeInterruptNested 0

fn KeInterrupt { ipl int handler -- }
	auto oldipl
	ipl@ KeIPLRaise oldipl!

	if (KeInterruptNested@ ~~)
		1 KeInterruptNested!

		int@ handler@ HALInterruptStackTop@ HALCPURunInContext

		HALCPUInterruptEnable

		// XXX there is a brief window here where an interrupt can occur,
		// and be handled outside of the interrupt stack. any interrupts
		// that are higher priority that occur during that interrupt will
		// also be handled in the interrupted thread's kernel stack,
		// rather than the interrupt thread.

		// this is considered fine because it is only possible for
		// interrupts to nest a max of 8 levels deep anyway, and it is
		// anticipated that the bulk of the time spent with
		// KeInterruptNested set to 1 will be spent in the interrupt handler.

		// however, it is possible to fix this case. i just don't consider
		// it worthwhile right now.

		oldipl@ KeIPLLower

		HALCPUInterruptDisable drop

		0 KeInterruptNested!
	end else
		HALCPUInterruptEnable

		int@ handler@ HALInterruptHandler

		HALCPUInterruptDisable drop

		// it's okay for KeIPLLower to run with interrupts disabled here
		// because it's impossible for it to drop below IPLDPC.

		// the problem with it running with interrupts disabled, which causes
		// the weird case above, is that DPCs must run with interrupts
		// enabled. it's totally fine here though because it's basically
		// just setting a variable and returning in this particular case.

		oldipl@ KeIPLLower
	end
end

externptr HALInterruptFunction

fn KeInterruptInit { -- }
	pointerof KeInterrupt HALInterruptFunction!
end
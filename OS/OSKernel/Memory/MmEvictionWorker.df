#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OSStatus.h"

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the eviction/swap thread

	auto evictionscore

	while (1)
		auto ok

		KERNELMODE // waitmode
		0 // alertable
		10000 // timeout (evict up to the high watermark every 10 seconds)
		MmEventLowMemory // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				if (ok@ STATUS_WAIT_TIMEOUT ~=)
					ok@ "MmEvictionWorker: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		auto evicted
		auto rs
		auto ipl

		0 evictionscore!

		while (1)
			if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
				IPLDPC KeIPLRaise ipl!

				// recheck at IPLDPC -- this seemingly redundant check
				// minimizes overhead in the more common case

				if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
					MmEventLowMemory // event
					KeEventReset drop

					ipl@ KeIPLLower

					break
				end

				ipl@ KeIPLLower
			end

			if (evictionscore@ 128 >=)
				// if we tried to unsuccessfully evict 128 times in a row,
				// odds are we're stuck in an infinite loop and we
				// need to let user threads run for a bit in order
				// to successfully evict any more pages.
				// go to sleep for 50ms.

				// TODO also try invalidating process PTEs here

				0 evictionscore!

				50 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
					end
				end

				0 ok!
			end

			HALCPUInterruptDisable rs!

			auto pfdbe
			MmEvictableFastPageListHead@ pfdbe!

			if (pfdbe@ ~~)
				// no fast page, try a slow page

				MmEvictablePageListHead@ pfdbe!
			end

			if (pfdbe@)
				pfdbe@ MmEvictablePageReference drop

				IPLDPC KeIPLRaise drop

				rs@ HALCPUInterruptRestore

				// we will call an MmEvictionFunction defined by the PFDBE.
				// this function's primary job is to perform whatever actions are
				// necessary to evict the page frame, such as writing it out to the
				// page file.

				// another equally important job of the MmEvictionFunction is to perform
				// whatever synchronization is needed between any other parts of the system
				// that make use of this page frame, and its eviction. if this synchronization
				// is not possible for any reason, the function returns 0 in the 'evicted'
				// return value. an example of a situation where this would occur would be
				// that the refcount increased to >1 between the page being selected for
				// eviction here, and a mutex being locked on it by the eviction function.

				auto evictionfuncs
				pfdbe@ MmPageFrameEntryEvictable_EvictableFunctions + @ evictionfuncs!

				if (DEBUGCHECKS)
					if (evictionfuncs@ ~~)
						"MmEvictionWorker: no eviction funcs for page\n" KeCrash
					end
				end

				auto evictionfunc
				evictionfuncs@ MmEvictableFunctions_EvictionFunc + @ evictionfunc!

				1 evicted!

				if (evictionfunc@)
					pfdbe@ // pfdbe
					evictionfunc@ MmEvictionFunction drop evicted!
				end

				if (evicted@)
					// evicted, free the page

					if (DEBUGCHECKS)
						if (pfdbe@ MmPageFrameEntryEvictable_References + @ 1 ~=)
							pfdbe@ MmPageFrameEntryEvictable_References + @
							"MmEvictionWorker: attempt to evict a page with %d references\n" KeCrash
						end
					end

					pfdbe@ MmPageFrameEntryEvictable_PFN + @ // pfn
					MmPageFree
				end

				if (evicted@ ~~)
					// not evicted, dereference and re-place at back of LRU queue

					pfdbe@ MmEvictablePageDereference drop

					1 evictionscore +=
				end else
					0 evictionscore!
				end

				IPLLOW KeIPLLower
			end else
				rs@ HALCPUInterruptRestore

				if (IOCacheModifiedPageListHead@)
					// there's some modified page frames.
					// go to sleep for 20ms with the hope that the modified page writer will have freed some up by
					// the time we wake up.

					20 // interval
					KERNELMODE // waitmode
					0 // alertable
					KeThreadSleep ok!

					if (DEBUGCHECKS)
						if (ok@ STATUS_WAIT_TIMEOUT ~=)
							ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
						end
					end
				end else
					// no evictable page frames.
					// invalidate/evict some process PTEs
					// to try to free some up

					"TODO evict processes\n" KeCrash
				end
			end
		end
	end
end
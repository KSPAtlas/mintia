#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the eviction/swap thread

	auto evictionscore

	while (1)
		auto ok

		KERNELMODE // waitmode
		0 // alertable
		TIMEOUTINFINITE // timeout
		MmEventLowMemory // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				"MmEvictionWorker: failed to wait on low memory event\n" KeCrash
			end
		end

		auto evicted
		auto rs
		auto ipl

		0 evictionscore!

		while (1)
			if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
				IPLDPC KeIPLRaise ipl!

				// recheck at IPLDPC -- this seemingly redundant check
				// minimizes overhead in the more common case

				if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
					MmEventLowMemory // event
					KeEventReset drop

					ipl@ KeIPLLower

					break
				end

				ipl@ KeIPLLower
			end

			HALCPUInterruptDisable rs!

			auto pfdbe
			MmEvictableFastPageListHead@ pfdbe!

			if (pfdbe@ ~~)
				// no fast page, try a slow page

				MmEvictablePageListHead@ pfdbe!
			end

			if (pfdbe@)
				pfdbe@ MmEvictablePageReference drop

				rs@ HALCPUInterruptRestore

				// MmPageEvict will call an MmEvictionFunction defined by the PFDBE.
				// this function's primary job is to perform whatever actions are
				// necessary to evict the page frame, such as writing it out to the
				// page file.

				// another equally important job of the MmEvictionFunction is to perform
				// whatever synchronization is needed between any other parts of the system
				// that make use of this page frame, and its eviction. if this synchronization
				// is not possible for any reason, the function returns 0 in the 'evicted'
				// return value. an example of a situation where this would occur would be
				// that the refcount increased to >1 between the page being selected for
				// eviction here, and a mutex being locked on it by the eviction function.

				pfdbe@ // pfdbe
				MmPageEvict ok! evicted!

				if (evicted@ ~~)
					// not evicted, dereference and re-place at back of LRU queue

					pfdbe@ MmEvictablePageDereference drop
				end

				1 evictionscore +=
			end else
				rs@ HALCPUInterruptRestore

				// no evictable page frames,
				// evict some processes

				"TODO evict processes\n" KeCrash
			end
		end
	end
end
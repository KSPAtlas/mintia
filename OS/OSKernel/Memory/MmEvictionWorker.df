#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the eviction/swap thread

	auto evictions
	0 evictions!

	while (1)
		auto ok

		KERNELMODE // waitmode
		0 // alertable
		TIMEOUTINFINITE // timeout
		MmEventLowMemory // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				"MmEvictionWorker: failed to wait on low memory event\n" KeCrash
			end
		end

		"evict!\n" Printf

		auto evicted
		auto rs
		auto ipl

		while (1)
			1 evictions +=

			if (evictions@ 63 & 0 ==)
				// sleep for 20ms for every 64 evictions,
				// attempted or successful, to make sure the
				// eviction thread doesn't wait too long to
				// give up time to lower priority threads...

				20 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep drop
			end

			IPLDPC KeIPLRaise ipl!

			if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
				MmEventLowMemory // event
				KeEventReset drop

				ipl@ KeIPLLower

				break
			end

			ipl@ KeIPLLower

			HALCPUInterruptDisable rs!

			auto pfdbe
			MmEvictablePageListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmEvictablePageReference drop

				rs@ HALCPUInterruptRestore

				pfdbe@ // pfdbe
				MmPageEvict ok! evicted!

				if (evicted@ ~~)
					// not evicted, dereference and re-place at back of LRU queue

					pfdbe@ MmEvictablePageDereference drop					
				end
			end else
				rs@ HALCPUInterruptRestore

				// no evictable page frames,
				// evict some processes

				"TODO evict processes\n" KeCrash
			end
		end
	end
end
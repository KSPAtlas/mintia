#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OSStatus.h"

// some assumptions:
// fast pages will never drop below IPLDPC while evicting.
// slow pages will never have dropped below IPLDPC if eviction failed.

const MMFASTPAGEEVICTCOUNT 128
const MMSLOWPAGEEVICTCOUNT 32

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the eviction/swap thread

	auto sleptonce
	0 sleptonce!

	auto pteinvlcount
	0 pteinvlcount!

	auto ipl

	while (1)
		auto ok

		KERNELMODE // waitmode
		0 // alertable
		10000 // timeout (evict up to the high watermark every 10 seconds)
		MmEventLowMemory // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				if (ok@ STATUS_WAIT_TIMEOUT ~=)
					ok@ "MmEvictionWorker: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
			IPLDPC KeIPLRaise ipl!

			// recheck at IPLDPC -- this seemingly redundant check
			// minimizes overhead in the more common case

			if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
				MmEventLowMemory // event
				KeEventReset drop

				ipl@ KeIPLLower

				0 sleptonce!
				0 pteinvlcount!

				continue
			end

			ipl@ KeIPLLower
		end

		if (pteinvlcount@)
			if (pteinvlcount@ 7 & ~~)
				// we've been here a lot of times...
				// giving up the processor for 75ms might untangle things and help
				// us evict more pages...

				75 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
					end
				end

				continue
			end
		end

		auto done

		MMFASTPAGEEVICTCOUNT // trycount
		1 // fast
		MmEvictableFastPageListHead // listhead
		MmEvictFromList ok! done!

		if (ok@)
			ok@ "MmEvictionWorker: fast page evict (%i)\n" KeCrash
		end

		if (done@)
			continue
		end

		if (sleptonce@ ~~)
			if (IOCacheModifiedPageListHead@)
				// there's some modified page frames.
				// go to sleep for 25ms with the hope that the modified page writer will have freed some up by
				// the time we wake up.

				1 sleptonce!

				25 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
					end
				end

				continue
			end
		end

		MMSLOWPAGEEVICTCOUNT // trycount
		0 // fast
		MmEvictablePageListHead // listhead
		MmEvictFromList ok! done!

		if (ok@)
			ok@ "MmEvictionWorker: slow page evict (%i)\n" KeCrash
		end

		if (done@)
			continue
		end

		// permit a sleep on the modified page list again
		0 sleptonce!

		1 pteinvlcount +=

		"MmEvictionWorker: TODO: invalidate PTEs\n" KeCrash
	end
end

fn MmEvictFromList { trycount fast listhead -- done ok }
	0 done!
	0 ok!

	auto succeedcount
	0 succeedcount!

	auto i
	0 i!

	auto pfdbe
	listhead@@ pfdbe!

	auto ipl

	if (pfdbe@)
		IPLDPC KeIPLRaise ipl!

		auto oldhead
		listhead@@ pfdbe!
		pfdbe@ oldhead!

		while (i@ trycount@ <)
			// check each page if the low memory situation is resolved

			if (pfdbe@ ~~)
				break
			end

			if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
				if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
					MmEventLowMemory // event
					KeEventReset drop

					ipl@ KeIPLLower

					1 done!

					return
				end
			end

			// we will call an MmEvictionFunction defined by the PFDBE.
			// this function's primary job is to perform whatever actions
			// are necessary to evict the page frame, such as writing it
			// out to the page file.

			// another equally important job of the MmEvictionFunction is
			// to perform whatever synchronization is needed between any
			// other parts of the system that make use of this page frame,
			// and its eviction. if this synchronization is not possible
			// for any reason, the function returns 0 in the 'evicted'
			// return value.

			auto evictionfuncs
			pfdbe@ MmPageFrameEntryEvictable_EvictableFunctions + @ evictionfuncs!

			if (DEBUGCHECKS)
				if (evictionfuncs@ ~~)
					"MmEvictFromList: no eviction funcs for page\n" KeCrash
				end
			end

			auto evictionfunc
			evictionfuncs@ MmEvictableFunctions_EvictionFunc + @ evictionfunc!

			if (DEBUGCHECKS)
				if (evictionfunc@ ~~)
					"MmEvictFromList: no eviction func for page\n" KeCrash
				end
			end

			auto evicted
			pfdbe@ // pfdbe
			evictionfunc@ MmEvictionFunction drop evicted!

			auto npfdbe

			if (evicted@)
				// evicted, free the page

				if (DEBUGCHECKS)
					if (pfdbe@ MmPageFrameEntryEvictable_References + @ 0 ~=)
						pfdbe@ MmPageFrameEntryEvictable_References + @
						"MmEvictFromList: attempt to evict a page with %d references\n" KeCrash
					end
				end

				1 succeedcount +=

				if (fast@)
					pfdbe@ MmPageFrameEntryEvictable_Next + @ npfdbe!
				end else
					// slow pages can't be trusted not to have dropped to
					// IPLLOW which would mean anything could have happened
					// to the evictable LRU and the next link is meaningless.

					0 oldhead!
					listhead@@ npfdbe!
				end

				pfdbe@ MmEvictablePageRemove

				pfdbe@ MmPageFrameEntryEvictable_PFN + @ // pfn
				MmPageFree
			end else
				pfdbe@ MmPageFrameEntryEvictable_Next + @ npfdbe!

				// failed to evict, put on MRU end so that we don't try it
				// again for a while

				if (npfdbe@)
					// if there wasn't npfdbe it'd already be on the tail.

					pfdbe@ MmEvictablePageRemove
					pfdbe@ MmEvictablePageInsert
				end
			end

			if (npfdbe@ oldhead@ ==)
				break
			end

			npfdbe@ pfdbe!
			1 i +=
		end

		ipl@ KeIPLLower
	end

	// at least half of the tries need to have worked
	succeedcount@ trycount@ 2 / >= done!
end
#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OSStatus.h"

const MMFASTPAGEEVICTCOUNT 128
const MMSLOWPAGEEVICTCOUNT 32

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the eviction/swap thread

	auto sleptonce
	0 sleptonce!

	auto pteinvlcount
	0 pteinvlcount!

	auto ipl

	while (1)
		auto ok

		KERNELMODE // waitmode
		0 // alertable
		10000 // timeout (evict up to the high watermark every 10 seconds)
		MmEventLowMemory // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				if (ok@ STATUS_WAIT_TIMEOUT ~=)
					ok@ "MmEvictionWorker: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
			IPLDPC KeIPLRaise ipl!

			// recheck at IPLDPC -- this seemingly redundant check
			// minimizes overhead in the more common case

			if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
				MmEventLowMemory // event
				KeEventReset drop

				ipl@ KeIPLLower

				0 sleptonce!
				0 pteinvlcount!

				continue
			end

			ipl@ KeIPLLower
		end

		if (pteinvlcount@)
			if (pteinvlcount@ 7 & ~~)
				// we've been here a lot of times...
				// giving up the processor for 75ms might untangle things and help
				// us evict more pages...

				75 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
					end
				end

				continue
			end
		end

		auto done

		MMFASTPAGEEVICTCOUNT // trycount
		MmEvictableFastPageListHead // listhead
		MmEvictFromList ok! done!

		if (ok@)
			ok@ "MmEvictionWorker: fast page evict (%i)\n" KeCrash
		end

		if (done@)
			continue
		end

		if (sleptonce@ ~~)
			if (IOCacheModifiedPageListHead@)
				// there's some modified page frames.
				// go to sleep for 50ms with the hope that the modified page writer will have freed some up by
				// the time we wake up.

				1 sleptonce!

				50 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
					end
				end

				continue
			end
		end

		MMSLOWPAGEEVICTCOUNT // trycount
		MmEvictablePageListHead // listhead
		MmEvictFromList ok! done!

		if (ok@)
			ok@ "MmEvictionWorker: slow page evict (%i)\n" KeCrash
		end

		if (done@)
			continue
		end

		// permit a sleep on the modified page list again
		0 sleptonce!

		1 pteinvlcount +=

		"MmEvictionWorker: TODO: invalidate PTEs\n" KeCrash
	end
end

fn MmEvictFromList { trycount listhead -- done ok }
	0 done!
	0 ok!

	auto succeedcount
	0 succeedcount!

	auto i
	0 i!

	auto ipl

	while (i@ trycount@ <)
		// check each page if the low memory situation is resolved

		if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
			IPLDPC KeIPLRaise ipl!

			// recheck at IPLDPC -- this seemingly redundant check
			// minimizes overhead in the more common case

			if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
				MmEventLowMemory // event
				KeEventReset drop

				ipl@ KeIPLLower

				1 done!

				return
			end

			ipl@ KeIPLLower
		end

		// low memory situation not resolved, attempt yoink

		IPLDPC KeIPLRaise ipl!

		auto pfdbe
		listhead@@ pfdbe!

		if (pfdbe@ ~~)
			ipl@ KeIPLLower

			return
		end

		pfdbe@ MmEvictablePageReference drop

		// we will call an MmEvictionFunction defined by the PFDBE.
		// this function's primary job is to perform whatever actions
		// are necessary to evict the page frame, such as writing it
		// out to the page file.

		// another equally important job of the MmEvictionFunction is
		// to perform whatever synchronization is needed between any
		// other parts of the system that make use of this page frame,
		// and its eviction. if this synchronization is not possible
		// for any reason, the function returns 0 in the 'evicted'
		// return value.

		auto evictionfuncs
		pfdbe@ MmPageFrameEntryEvictable_EvictableFunctions + @ evictionfuncs!

		if (DEBUGCHECKS)
			if (evictionfuncs@ ~~)
				"MmEvictFromList: no eviction funcs for page\n" KeCrash
			end
		end

		auto evictionfunc
		evictionfuncs@ MmEvictableFunctions_EvictionFunc + @ evictionfunc!

		auto evicted
		1 evicted!

		if (evictionfunc@)
			pfdbe@ // pfdbe
			evictionfunc@ MmEvictionFunction drop evicted!
		end

		if (evicted@)
			// evicted, free the page

			if (DEBUGCHECKS)
				if (pfdbe@ MmPageFrameEntryEvictable_References + @ 1 ~=)
					pfdbe@ MmPageFrameEntryEvictable_References + @
					"MmEvictFromList: attempt to evict a page with %d references\n" KeCrash
				end
			end

			1 succeedcount +=

			pfdbe@ MmPageFrameEntryEvictable_PFN + @ // pfn
			MmPageFree
		end else
			// not evicted, dereference and re-place at back of LRU queue

			pfdbe@ MmEvictablePageDereference drop
		end

		ipl@ KeIPLLower

		1 i +=
	end

	succeedcount@ trycount@ == done!
end
#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

var MmHeapBlockUsedListHead 0

fn MmPageGet { priority threshold -- pfdbe pfn ok }
	0 ok!

	if (DEBUGCHECKS)
		if (MmInited@ ~~)
			"MmPageAlloc: used before MmInit called\n" KeCrash
		end
	end

	0xFF priority &=

	auto rs

	if (priority@ FREEFIRST ==)
		// attempt to get a page from the free list first.
		// if its empty, try to get one from the zero list.

		HALCPUInterruptDisable rs!

		if (MmPageFreeCount@ threshold@ <=)
			rs@ HALCPUInterruptRestore

			STATUS_NO_MEMORY ok!

			return
		end

		MmPageFreeListHead@ pfdbe!

		if (pfdbe@)
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			1 MmPageFreeCount -=
		end else
			// resort to a zero page

			MmPageZeroListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmPageFrameEntry_PFN + @ pfn!
				pfdbe@ MmPageFrameEntryFree_Next + @ MmPageZeroListHead!
				0 pfdbe@ MmPageFrameEntryFree_Next + !

				1 MmPageFreeCount -=
			end else
				STATUS_NO_MEMORY ok!
			end
		end

		rs@ HALCPUInterruptRestore

		return
	end elseif (priority@ ZEROMUST ==)
		// attempt to get one from the zero list first.
		// if its empty, get one from the free list, and zero it out.

		HALCPUInterruptDisable rs!

		if (MmPageFreeCount@ threshold@ <=)
			rs@ HALCPUInterruptRestore

			STATUS_NO_MEMORY ok!

			return
		end

		MmPageZeroListHead@ pfdbe!

		if (pfdbe@)
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageZeroListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			1 MmPageFreeCount -=

			rs@ HALCPUInterruptRestore

			return
		end else
			// resort to a free page

			MmPageFreeListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmPageFrameEntry_PFN + @ pfn!
				pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
				0 pfdbe@ MmPageFrameEntryFree_Next + !

				1 MmPageFreeCount -=

				rs@ HALCPUInterruptRestore

				// zero the free page out

				pfn@ 12 <<
				4096
				0
				memset

				return
			end else
				STATUS_NO_MEMORY ok!

				rs@ HALCPUInterruptRestore

				return
			end
		end

		if (DEBUGCHECKS)
			"MmPageGet\n" KeCrash
		end
	end else
		priority@ "MmPageGet: unknown priority %d\n" KeCrash
	end
end

fn MmPageAlloc { priority -- pfdbe pfn ok }
	0 ok!

	if (DEBUGCHECKS)
		if (MmInited@ ~~)
			"MmPageAlloc: used before MmInit called\n" KeCrash
		end
	end

	auto blockon
	auto alertable
	auto tries

	if (priority@ MUSTSUCCEED &)
		// CANBLOCK page allocations have different wait rules
		// if MUSTSUCCEED is also specified:

		0 blockon! // can dip into MUSTSUCCEED page pool
		0 alertable! // wait can't be interrupted
		-1 tries! // try forever for a page
	end else
		// normal rules for a CANBLOCK allocation:

		MMMUSTSUCCEEDPAGES blockon! // don't dip into MUSTSUCCEED page pool
		1 alertable! // wait can be interrupted
		6 tries! // try 6 times to get a page
		// each try is 250ms, so there's 6 * 250ms = 1.5 seconds until we admit defeat.
	end

	while (1)
		priority@ // priority
		blockon@ // threshold
		MmPageGet ok! pfn! pfdbe!

		if (ok@ 0 ==)
			if (MmPageFreeCount@ MmPageFreeCountLow@ <)
				auto ipl
				IPLDPC KeIPLRaise ipl!

				// recheck at IPLDPC -- this seemingly redundant check
				// minimizes overhead in the more common case

				if (MmPageFreeCount@ MmPageFreeCountLow@ <)
					0 // priboost
					MmEventLowMemory // event
					KeEventSignal ok!

					if (DEBUGCHECKS)
						if (ok@)
							ok@ "MmPageAlloc: couldn't signal event\n" KeCrash
						end
					end
				end

				ipl@ KeIPLLower
			end

			return
		end

		if (DEBUGCHECKS)
			if (ok@ STATUS_NO_MEMORY ~=)
				ok@ "MmPageAlloc: MmPageGet returned weird status (%i)\n" KeCrash
			end
		end

		if (priority@ CANBLOCK &)
			KERNELMODE // waitmode
			alertable@ // alertable
			250 // timeout
			MmEventPageAvailable // object
			KeThreadWaitForObject ok!

			if (ok@ STATUS_WAIT_TIMEOUT ==)
				if (tries@ -1 ~=)
					1 tries -=

					if (tries@ ~~)
						STATUS_NO_MEMORY ok!

						return
					end
				end
			end elseif (ok@)
				return
			end
		end elseif (priority@ MUSTSUCCEED &)
			"MmPageAlloc: MUSTSUCCEED allocation failed\n" KeCrash
		end else
			return
		end
	end
end

fn MmPageFree { pfn -- }
	// insert a page frame into the free list

	auto pfdbe

	pfn@ MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto rs
	HALCPUInterruptDisable rs!

	MmPageFreeListHead@ pfdbe@ MmPageFrameEntryFree_Next + !
	pfdbe@ MmPageFreeListHead!

	1 MmPageFreeCount +=

	rs@ HALCPUInterruptRestore

	auto ok

	0 // priboost
	MmEventPageAvailable // event
	KeEventSignal ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmPageFree: couldn't signal event\n" KeCrash
		end
	end
end

fn MmHeapPrintTag { tag -- }
	auto shf
	32 shf!

	while (shf@)
		8 shf -=

		auto c
		tag@ shf@ >> 0xFF & c!

		if (c@ 0x80 & ~~ c@ 0x20 >= &&)
			c@ Putc
		end else
			'!' Putc
		end
	end
end

fn MmHeapCheck { -- }
	if (DEBUGCHECKS ~~)
		"MmHeapCheck: wasn't compiled with DEBUGCHECKS\n" KeCrash
	end

	auto i
	0 i!

	auto base
	MmHeap@ base!

	auto sz
	1 BUCKETSPO2START << sz!

	while (i@ BUCKETS <)
		i@ "checking [%d]MemBuckets\n" Printf

		auto block
		[i@]MmHeapBuckets@ block!

		if (block@)
			if (block@ MmHeapBlock_Prev + @)
				block@ MmHeapBlock_Prev + @ "!!! head had a prev 0x%08x\n" Printf
			end
		end

		while (block@)
			if (block@ 0x3 &)
				block@ "!!!! unaligned block ptr 0x%08x\n" Printf
				break
			end

			if (block@ MmHeapBlock_Magic + @ HEAPBLOCKMAGIC ~=)
				"!!!! bad magic:\n" Printf
				block@ MmHeapDumpBlockInfoHdr
				break
			end

			if (block@ MmHeapBlock_Tag + @ HEAPBLOCKFREE ~=)
				"!!! bad tag:\n" Printf
				block@ MmHeapDumpBlockInfoHdr
			end

			if (block@ MmHeapBlock_BucketIndex + @ i@ ~=)
				"!!! bad bucketindex:\n" Printf
				block@ MmHeapDumpBlockInfoHdr
			end

			auto buddy
			block@ base@ - sz@ ^ base@ + buddy!

			if (buddy@ MmHeapBlock_Magic + @ HEAPBLOCKMAGIC ~=)
				"!!! bad buddy. main guy:\n" Printf
				block@ MmHeapDumpBlockInfoHdr
				"buddy:\n" Printf
				buddy@ MmHeapDumpBlockInfoHdr
			end else
				if (buddy@ MmHeapBlock_Tag + @ HEAPBLOCKFREE ==)
					// check if buddy is on the proper list

					auto blockb
					[buddy@ MmHeapBlock_BucketIndex + @]MmHeapBuckets@ blockb!

					auto found
					0 found!

					while (blockb@)
						if (blockb@ buddy@ ==)
							1 found!
							break
						end

						blockb@ MmHeapBlock_Next + @ blockb!
					end

					if (found@ ~~)
						"!!! buddy was free but not on free list:\n" Printf
						buddy@ MmHeapDumpBlockInfoHdr
					end
				end
			end

			auto nextblock
			block@ MmHeapBlock_Next + @ nextblock!

			if (nextblock@)
				if (nextblock@ 0x3 & ~~)
					if (nextblock@ MmHeapBlock_Prev + @ block@ ~=)
						"!!! prev didn't match:\n" Printf
						block@ MmHeapDumpBlockInfoHdr
					end
				end
			end

			nextblock@ block!
		end

		1 sz <<=
		1 i +=
	end

	"checking used block list\n" Printf

	MmHeapBlockUsedListHead@ block!

	if (block@)
		if (block@ MmHeapBlock_Prev + @)
			block@ MmHeapBlock_Prev + @ "!!! head had a prev 0x%08x\n" Printf
		end
	end

	while (block@)
		block@ "checking 0x%08x" Printf

		if (block@ 0x3 &)
			block@ "\n!!!! unaligned block ptr 0x%08x\n" Printf
			break
		end

		' ' Putc

		block@ MmHeapBlock_Tag + @ MmHeapPrintTag

		'\n' Putc

		if (block@ MmHeapBlock_Magic + @ HEAPBLOCKMAGIC ~=)
			"\n!!!! bad magic:\n" Printf
			block@ MmHeapDumpBlockInfoHdr
			break
		end

		1 block@ MmHeapBlock_BucketIndex + @ BUCKETSPO2START + << sz!

		block@ base@ - sz@ ^ base@ + buddy!

		if (buddy@ MmHeapBlock_Magic + @ HEAPBLOCKMAGIC ~=)
			"!!! bad buddy. main guy:\n" Printf
			block@ MmHeapDumpBlockInfoHdr
			"buddy:\n" Printf
			buddy@ MmHeapDumpBlockInfoHdr
		end else
			if (buddy@ MmHeapBlock_Tag + @ HEAPBLOCKFREE ==)
				// check if buddy is on the proper list

				[buddy@ MmHeapBlock_BucketIndex + @]MmHeapBuckets@ blockb!

				0 found!

				while (blockb@)
					if (blockb@ buddy@ ==)
						1 found!
						break
					end

					blockb@ MmHeapBlock_Next + @ blockb!
				end

				if (found@ ~~)
					"!!! buddy was free but not on free list:\n" Printf
					buddy@ MmHeapDumpBlockInfoHdr
				end
			end
		end

		block@ MmHeapBlock_Next + @ nextblock!

		if (nextblock@)
			if (nextblock@ 0x3 & ~~)
				if (nextblock@ MmHeapBlock_Prev + @ block@ ~=)
					"!!! prev didn't match:\n" Printf
					block@ MmHeapDumpBlockInfoHdr
				end
			end
		end

		nextblock@ block!
	end
end

fn MmHeapDumpBlockInfoHdr { block -- }
	block@ "header @ %08x\n" Printf

	block@ MmHeapBlock_Magic + @ "  magic=%08x\n" Printf
	block@ MmHeapBlock_Next + @ "  next=%08x\n" Printf
	block@ MmHeapBlock_Prev + @ "  prev=%08x\n" Printf
	block@ MmHeapBlock_BucketIndex + @ dup BUCKETSPO2START + 1 swap << swap "  bucketindex=%d (%d bytes)\n" Printf
	block@ MmHeapBlock_Tag + @ "  tag=%08x\n" Printf
end

fn MmHeapDumpBlockInfo { block -- }
	block@ MmHeapBlock_SIZEOF - MmHeapDumpBlockInfoHdr
end

fn MmHeapDumpBuckets { -- }
	auto i
	0 i!

	auto sz
	1 BUCKETSPO2START << sz!

	while (i@ BUCKETS <)
		sz@ "[%d]: " Printf

		auto ptr
		[i@]MmHeapBuckets@ ptr!

		while (ptr@)
			auto bsz
			1 ptr@ MmHeapBlock_BucketIndex + @ BUCKETSPO2START + << bsz!

			bsz@ bsz@ ptr@ + MmHeap@ - ptr@ MmHeap@ - "%x-%x (%d) | " Printf

			ptr@ MmHeapBlock_Next + @ ptr!
		end

		'\n' Putc

		1 sz <<=
		1 i +=
	end
end

// fn MmAllocWithTagCharge { bytes tag -- ptr ok }
// 	auto charge
// 	bytes@ MmChargeBytesGet charge!

// 	charge@ MmQuotaCharge ok!

// 	if (ok@)
// 		return
// 	end

// 	bytes@ tag@ MmAllocWithTag ok! ptr!

// 	if (ok@)
// 		charge@ MmQuotaUncharge

// 		return
// 	end
// end

fn MmAllocWithTag { bytes tag -- ptr ok }
	if (DEBUGCHECKS)
		if (MmInited@ ~~)
			"MmAllocWithTag: used before MemInit called\n" KeCrash
		end
	end

	MmHeapBlock_SIZEOF bytes +=

	auto sz
	1 BUCKETSPO2START << sz!

	auto i
	0 i!

	auto dist
	-1 dist!

	STATUS_NO_MEMORY ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	while (i@ BUCKETS <)
		if (bytes@ sz@ <=)
			if (dist@ -1 ==)
				i@ dist!
			end

			[i@]MmHeapBuckets@ ptr!

			if (ptr@)
				auto ts
				sz@ ts!

				auto pt
				ptr@ MmHeapBlock_Next + @ pt!

				pt@ [i@]MmHeapBuckets!

				if (pt@)
					0 pt@ MmHeapBlock_Prev + !
				end

				while (i@ dist@ >)
					1 i -=
					1 ts >>=

					auto tp
					ptr@ ts@ + tp!

					HEAPBLOCKMAGIC tp@ MmHeapBlock_Magic + !
					i@ tp@ MmHeapBlock_BucketIndex + !
					HEAPBLOCKFREE tp@ MmHeapBlock_Tag + !
					0 tp@ MmHeapBlock_Prev + !

					[i@]MmHeapBuckets@ pt!

					if (pt@)
						tp@ pt@ MmHeapBlock_Prev + !
					end

					pt@ tp@ MmHeapBlock_Next + !
					tp@ [i@]MmHeapBuckets!
				end

				HEAPBLOCKMAGIC ptr@ MmHeapBlock_Magic + !
				i@ ptr@ MmHeapBlock_BucketIndex + !
				tag@ ptr@ MmHeapBlock_Tag + !

				1 i@ BUCKETSPO2START + << MmHeapBytesFree -=

				if (DEBUGCHECKS)
					// add to used block list

					0 ptr@ MmHeapBlock_Prev + !

					MmHeapBlockUsedListHead@ ts!

					if (ts@)
						ptr@ ts@ MmHeapBlock_Prev + !
					end

					ptr@ MmHeapBlockUsedListHead!

					ts@ ptr@ MmHeapBlock_Next + !
				end

				0 ok!
				MmHeapBlock_SIZEOF ptr +=

				break
			end
		end

		1 sz <<=
		1 i +=
	end

	ipl@ KeIPLLower
end

fn MmFree { ptr -- }
	if (DEBUGCHECKS)
		if (MmInited@ ~~)
			"MmFree: used before MemInit called\n" KeCrash
		end

		if (ptr@ -1 ==)
			"MmFree: tried to free -1 pointer\n" KeCrash
		end
	end

	if (ptr@ ~~)
		"MmFree: tried to free null pointer\n" KeCrash
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	MmHeapBlock_SIZEOF ptr -=

	if (ptr@ MmHeapBlock_Magic + @ HEAPBLOCKMAGIC ~=)
		ptr@ "MmFree: tried to free corrupted heap block (0x%08x)\n" KeCrash
	end

	if (ptr@ MmHeapBlock_Tag + @ HEAPBLOCKFREE ==)
		ptr@ "MmFree: tried to free heap block that was free (0x%08x)\n" KeCrash
	end

	if (DEBUGCHECKS)
		// remove from used block list

		ptr@ MmHeapBlock_Prev + @ l!

		ptr@ MmHeapBlock_Next + @ n!

		if (l@)
			n@ l@ MmHeapBlock_Next + !
		end else
			// no last block means was list head

			n@ MmHeapBlockUsedListHead!
		end

		if (n@)
			l@ n@ MmHeapBlock_Prev + !
		end
	end

	auto hpsz
	MmHeapSize@ hpsz!

	auto base
	MmHeap@ base!

	auto i
	ptr@ MmHeapBlock_BucketIndex + @ i!

	auto sz
	1 ptr@ MmHeapBlock_BucketIndex + @ BUCKETSPO2START + << sz!

	sz@ MmHeapBytesFree +=

	while (i@ BUCKETS 1 - <)
		if (sz@ hpsz@ >=)
			break
		end

		auto buddy
		ptr@ base@ - sz@ ^ base@ + buddy!

		if (buddy@ MmHeapBlock_Magic + @ HEAPBLOCKMAGIC ~=)
			buddy@ "MmFree: corrupted buddy (0x%08x)\n" KeCrash
		end

		if (buddy@ MmHeapBlock_Tag + @ HEAPBLOCKFREE ==)
			if (DEBUGCHECKS)
				if (buddy@ MmHeapBlock_BucketIndex + @ i@ ~=)
					buddy@ "MmFree: buddy has bad bucket index (0x%08x)\n" KeCrash
				end
			end

			// coalesce

			// remove buddy, who is free, from the bucket he's listed on

			auto l
			buddy@ MmHeapBlock_Prev + @ l!

			auto n
			buddy@ MmHeapBlock_Next + @ n!

			if (l@)
				n@ l@ MmHeapBlock_Next + !
			end else
				// no last block means buddy was the bucket list head
				n@ [i@]MmHeapBuckets!
			end

			if (n@)
				l@ n@ MmHeapBlock_Prev + !
			end

			if (buddy@ ptr@ >)
				0 buddy@ MmHeapBlock_Magic + !
				i@ 1 + ptr@ MmHeapBlock_BucketIndex + !
			end else
				0 ptr@ MmHeapBlock_Magic + !
				i@ 1 + buddy@ MmHeapBlock_BucketIndex + !
				buddy@ ptr!
			end
		end else
			// buddy's not free, can't do any more coalescing

			break
		end

		1 sz <<=
		1 i +=
	end

	HEAPBLOCKFREE ptr@ MmHeapBlock_Tag + !

	auto pt
	[i@]MmHeapBuckets@ pt!

	if (pt@)
		ptr@ pt@ MmHeapBlock_Prev + !
	end

	pt@ ptr@ MmHeapBlock_Next + !

	0 ptr@ MmHeapBlock_Prev + !

	ptr@ [i@]MmHeapBuckets!

	ipl@ KeIPLLower
end

fn MmChargeBytesGet { bytes -- charge }
	MmHeapBlock_SIZEOF bytes +=

	1 BUCKETSPO2START << charge!

	while (charge@ bytes@ <)
		1 charge <<=
	end
end

fn MmBlockChargeGet { block -- charge }
	MmHeapBlock_SIZEOF block -=

	if (DEBUGCHECKS)
		if (block@ MmHeapBlock_Magic + @ HEAPBLOCKMAGIC ~=)
			block@ MmHeapBlock_Magic + @ "MmBlockChargeGet: block had invalid magic number 0x%08x\n" KeCrash
		end
	end

	1 block@ MmHeapBlock_BucketIndex + @ BUCKETSPO2START + << charge!
end

fn MmKernelStackAlloc { -- kstack ok }
	FREEFIRST CANBLOCK | // priority
	MmPageAlloc ok! kstack! drop

	if (ok@)
		return
	end

	12 kstack <<=
	IDENTITYSPACE kstack |=
end

fn MmKernelStackFree { kstack -- }
	IDENTITYSPACE ~ kstack &=
	kstack@ 12 >> MmPageFree
end
#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

// routines for creating, destroying, and manipulating
// Virtual Address Descriptors (VADs).

fn MmVADCreate { startva endva prot offset sectionobject vadtype -- vad ok }
	// allocates a VAD structure.

	// if vadtype == VADTYPE_NORMAL it's a normal VAD, otherwise it's a COW
	// VAD, which is a smaller structure.

	// references the section object.

	if (vadtype@ VADTYPE_NORMAL ==)
		MmVAD_SIZEOF // bytes
		'nVAD' // tag
		MmAllocWithTag ok! vad!

		if (ok@)
			return
		end

		sectionobject@ ObObjectReferenceByPointer drop

		sectionobject@ vad@ MmVAD_SectionObject + !
		offset@ vad@ MmVAD_OffsetInSection + !
	end else
		if (DEBUGCHECKS)
			if (sectionobject@)
				"MmVADCreate: COW VAD but section object provided\n" KeCrash
			end

			if (offset@)
				"MmVADCreate: COW VAD but offset provided\n" KeCrash
			end
		end

		MmVADCopyOnWrite_SIZEOF // bytes
		'cVAD' // tag
		MmAllocWithTag ok! vad!

		if (ok@)
			return
		end
	end

	0 vad@ MmVAD_Next + !
	0 vad@ MmVAD_Prev + !
	vadtype@ vad@ MmVAD_Type + !
	startva@ vad@ MmVAD_StartVA + !
	endva@ vad@ MmVAD_EndVA + !
	prot@ vad@ MmVAD_PageProtection + !
end

fn MmVADFindFreeRegion { viewsize startva fixedva pageprotection sectionobject vadlisthead -- realva ok }
	// find a fitting region with a preferred virtual address of startva.
	// if fixedva is true, then *only* this virtual address can be used; if
	// it is not available an error will be returned.
	// this region could be completely empty, or it could be populated with
	// any number of compatible VADs.

	"MmVADFindFreeRegion: TODO: that\n" KeCrash
end
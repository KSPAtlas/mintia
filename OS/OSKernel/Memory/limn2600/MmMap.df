#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

extern HALLimn2500TLBFlush { vpn asid -- }
extern HALLimn2500TLBFlushAll { -- }

fn MmFlushUserTLBAll { -- }
	// XXX we might be able to have this function flush only the userspace
	// part of the TLB at some point.

	HALLimn2500TLBFlushAll
end

fn MmGetVirtualAddress { vaddr pagemap -- flags phyaddr pte ok }
	// get the PTE for a virtual address (for instances like, finding out if
	// a page is in swap)

	IDENTITYSPACE pagemap |=

	auto pdi
	vaddr@ 22 >> 2 << pagemap@ + @ pdi!

	pdi@ 5 >> 12 << pagemap!

	if (pagemap@ ~~)
		-1 ok!
		0 phyaddr!
		0 flags!
		0 pte!

		return
	end

	IDENTITYSPACE pagemap |=

	vaddr@ 12 >> 1023 & 2 << pagemap@ + @ pte!

	if (pte@ PTE_V & ~~)
		-1 ok!
	end

	pte@ 31 & flags!
	pte@ 5 >> 12 << phyaddr!

	0 ok!
end

fn MmMapVirtualAddress { phyaddr vaddr flags pagemap -- ok }
	// caller should take care of any locking

	IDENTITYSPACE pagemap |=

	0 ok!

	auto pdi
	vaddr@ 22 >> 2 << pagemap@ + pdi!

	auto pt
	pdi@@ 5 >> PAGESHIFT << pt!

	if (pt@ 0 ==)
		// need to allocate this page table

		auto pfdbe
		ZEROMUST MUSTSUCCEED | // priority
		MmPageAlloc ok! pt! pfdbe!

		if (ok@)
			return
		end

		0 pfdbe@ MmPageFrameEntryPageTable_PTECount + !

		pt@ 5 << PTE_V | pdi@!

		PAGESHIFT pt <<=
		IDENTITYSPACE pt |=
	end else
		pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!
		IDENTITYSPACE pt |=
	end

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pdi!

	if (pdi@@ PTE_V &)
		pdi@@ vaddr@ "MmMapVirtualAddress: 0x%08x is already mapped (pte=0x%08x)!\n" KeCrash
	end

	phyaddr@ PAGESHIFT >> 5 << flags@ | pdi@!

	1 pfdbe@ MmPageFrameEntryPageTable_PTECount + +=
end

fn MmRemapVirtualAddress { phyaddr vaddr flags asid pagemap -- pteaddr ok }
	// caller should take care of any locking

	IDENTITYSPACE pagemap |=

	0 ok!

	auto pdi
	vaddr@ 22 >> 2 << pagemap@ + pdi!

	auto pt
	pdi@@ 5 >> PAGESHIFT << pt!

	if (pt@ 0 ==)
		// need to allocate this page table

		auto pfdbe

		ZEROMUST MUSTSUCCEED | // priority
		MmPageAlloc ok! pt! pfdbe!

		if (ok@)
			return
		end

		0 pfdbe@ MmPageFrameEntryPageTable_PTECount + !

		pt@ 5 << PTE_V | pdi@!

		PAGESHIFT pt <<=
		IDENTITYSPACE pt |=
	end else
		pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!
		IDENTITYSPACE pt |=
	end

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!

	if (pteaddr@@ PTE_V &)
		if (pteaddr@@ 31 & flags@ ~=)
			// flush TLB entry

			if (DEBUGCHECKS)
				if (asid@ 0 ==)
					"MmRemapVirtualAddress: asid == 0\n" KeCrash
				end
			end

			vaddr@ PAGESHIFT >> // vpn
			asid@ 255 & 1 + // asid
			HALLimn2500TLBFlush
		end
	end elseif (pdi@@ ~~)
		1 pfdbe@ MmPageFrameEntryPageTable_PTECount + +=
	end

	phyaddr@ PAGESHIFT >> 5 << flags@ | pteaddr@!
end

fn MmSetVirtualAddress { pte vaddr pagemap -- ok }
	// set the pte for the virtual address (for instances like, in order to
	// keep track of where the page frame is in swap)

	"MmSetVirtualAddress: TODO\n" KeCrash
end

fn MmUnmapVirtualAddress { vaddr asid pagemap canfree attempt -- pte phyaddr ok }
	// caller should take care of any locking

	IDENTITYSPACE pagemap |=

	0 pte!
	0 ok!

	auto pdi
	vaddr@ 22 >> 2 << pagemap@ + pdi!

	auto pt
	pdi@@ 5 >> PAGESHIFT << pt!

	if (pt@ 0 ==)
		-1 ok!

		return
	end

	auto pfdbe
	pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pdi!

	pdi@@ pte!

	if (pte@ PTE_V & ~~)
		if (attempt@)
			// failing is fine
			-1 ok!

			if (pte@ 12 >> ~~)
				return
			end

			// there was a swap offset, fall thru and dereference the page
			// table.
		end else
			vaddr@ "MmUnmapVirtualAddress: 0x%08x wasn't mapped!\n" KeCrash
		end
	end else
		pte@ 5 >> PAGESHIFT << phyaddr!

		0 pdi@!

		if (asid@ 0 ==)
			vaddr@ PAGESHIFT >> // vpn
			0 // asid
			HALLimn2500TLBFlush
		end else
			vaddr@ PAGESHIFT >> // vpn
			asid@ 255 & 1 + // asid
			HALLimn2500TLBFlush
		end
	end

	auto oldcount
	pfdbe@ MmPageFrameEntryPageTable_PTECount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmUnmapVirtualAddress: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - pfdbe@ MmPageFrameEntryPageTable_PTECount + !

	if (canfree@)
		if (oldcount@ 1 ==)
			// there are no more mappings in this page table.
			// it can be freed

			pfdbe@ MmPageFrameEntry_PFN + @ MmPageFree
		end
	end
end

fn MmMapUnmodifyPTE { pteaddr -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmMapUnmodifyPTE: ipl != IPLDPC\n" KeCrash
		end
	end

	// clear writable bit
	0xFFFFFFFD pteaddr@ &=

	MmFlushUserTLBAll
end

fn MmPageDirectoryInitialize { pagemap -- }
	// identically map kernel space into the new page directory...

	pagemap@ IDENTITYSPACE | 2048 + // dest
	HALPlatformKernelPageDirectory@ IDENTITYSPACE | 2048 + // src
	2048 // size
	memcpy
end
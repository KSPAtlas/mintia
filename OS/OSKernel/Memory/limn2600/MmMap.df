#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

extern HALLimn2500TLBFlush { vpn asid -- }

fn MmGetPhysicalAddress { vaddr pagemap -- flags phyaddr ok }
	IDENTITYSPACE pagemap |=

	auto pdi
	vaddr@ 22 >> 2 << pagemap@ + @ pdi!

	pdi@ 5 >> 12 << pagemap!

	if (pagemap@ ~~)
		-1 ok!

		return
	end

	IDENTITYSPACE pagemap |=

	auto pte
	vaddr@ 12 >> 1023 & 2 << pagemap@ + @ pte!

	if (pte@ PTE_V & ~~)
		-1 ok!

		return
	end

	pte@ 31 & flags!
	pte@ 5 >> 12 << phyaddr!
	0 ok!
end

fn MmMapVirtualAddress { phyaddr vaddr flags pagemap canalloc -- ok }
	// caller should take care of any locking

	IDENTITYSPACE pagemap |=

	0 ok!

	auto pdi
	vaddr@ 22 >> 2 << pagemap@ + pdi!

	auto pt
	pdi@@ 5 >> PAGESHIFT << pt!

	if (pt@ 0 ==)
		// need to allocate this page table

		auto pfdbe

		if (canalloc@)
			ZEROMUST CANBLOCK | // priority
			MmPageAlloc ok! pt! pfdbe!

			if (ok@)
				return
			end
		end else
			STATUS_NO_MEMORY ok!

			return
		end

		0 pfdbe@ MmPageFrameEntryPageTable_PTECount + !

		pt@ 5 << PTE_V | pdi@!

		PAGESHIFT pt <<=
		IDENTITYSPACE pt |=
	end else
		pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!
		IDENTITYSPACE pt |=
	end

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pdi!

	if (pdi@@ PTE_V &)
		vaddr@ PAGESHIFT >> "MmMapVirtualAddress: vpn 0x%08x is already mapped!\n" KeCrash
	end

	phyaddr@ PAGESHIFT >> 5 << flags@ | pdi@!

	1 pfdbe@ MmPageFrameEntryPageTable_PTECount + +=
end

fn MmUnmapVirtualAddress { vaddr asid pagemap canfree -- phyaddr ok }
	// caller should take care of any locking

	IDENTITYSPACE pagemap |=

	0 ok!

	auto pdi
	vaddr@ 22 >> 2 << pagemap@ + @ pdi!

	auto pt
	pdi@@ 5 >> PAGESHIFT << pt!

	if (pt@ 0 ==)
		-1 ok!

		return
	end

	auto pfdbe
	pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pdi!

	if (pdi@@ PTE_V & ~~)
		vaddr@ PAGESHIFT >> "MmUnmapVirtualAddress: vpn 0x%08x wasn't mapped!\n" KeCrash
	end

	pdi@@ 5 >> PAGESHIFT << phyaddr!

	0 pdi@!

	if (asid@ 0 ==)
		vaddr@ PAGESHIFT >> // vpn
		0 // asid
		HALLimn2500TLBFlush
	end else
		vaddr@ PAGESHIFT >> // vpn
		asid@ 255 & 1 + // asid
		HALLimn2500TLBFlush
	end

	auto oldcount
	pfdbe@ MmPageFrameEntryPageTable_PTECount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmUnmapVirtualAddress: underflow\n" KeCrash
		end
	end

	if (canfree@)
		if (oldcount@ 1 ==)
			// there are no more mappings in this page table.
			// it can be freed

			pt@ PAGESHIFT >> MmPageFree
		end
	end

	oldcount@ 1 - pfdbe@ MmPageFrameEntryPageTable_PTECount + !
end

fn MmPageDirectoryInitialize { pagemap -- }
	// identically map kernel space into the new page directory...

	pagemap@ IDENTITYSPACE | 2048 + // dest
	HALPlatformKernelPageDirectory@ IDENTITYSPACE | 2048 + // src
	2048 // size
	memcpy
end
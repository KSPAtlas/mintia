#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALDebug.h"

fn ExHandleTableDelete { func handletable -- }
	auto ok

	if (DEBUGCHECKS)
		// this check isnt foolproof or anything because nothing stops
		// someone with a stray pointer from locking the mutex between
		// here and the table's destruction, but its useful anyway

		if (handletable@ ExHandleTableHeader_Mutex + KeMutexIsLocked)
			"ExHandleTableDelete: attempt to delete handle table while locked\n" KeCrash
		end
	end

	auto i

	auto entries

	auto entryptr

	if (func@)
		// call a function for each handle

		0 i!

		handletable@ ExHandleTableHeader_Entries + @ entries!

		while (i@ entries@ <)
			i@
			handletable@
			1 // locked
			ExHandleLookup ok! entryptr!

			if (ok@ 0 ==)
				entryptr@ i@ handletable@ func@ ExHandleEnumFunction ok!

				if (DEBUGCHECKS)
					if (ok@)
						ok@ func@ "ExHandleTableDelete: delete function at 0x%08x failed (%i)\n" KeCrash
					end
				end
			end

			1 i +=
		end
	end

	// deallocate handle table structures

	auto chargedprocess
	handletable@ ExHandleTableHeader_ChargedProcess + @ chargedprocess!

	if (chargedprocess@)
		handletable@ MmBlockChargeGet
		chargedprocess@ MmQuotaUnchargeProcess
	end

	auto tab
	handletable@ ExHandleTableHeader_Table + @ tab!

	if (tab@)
		if (chargedprocess@)
			tab@ MmBlockChargeGet
			chargedprocess@ MmQuotaUnchargeProcess
		end

		tab@ MmFree
	end

	handletable@ MmFree
end

fn ExHandleTableDuplicate { func handletablesrc chargedprocess -- handletable ok }
	"ExHandleTableDuplicate: untested! please review me\n" KeCrash

	handletablesrc@ ExHandleTableLock ok!

	if (ok@)
		return
	end

	auto entrysizelog
	handletablesrc@ ExHandleTableHeader_EntrySizeLog + @ entrysizelog!

	chargedprocess@ // chargedprocess
	entrysizelog@ // entrysizelog
	ExHandleTableCreate ok! handletable!

	if (ok@)
		handletablesrc@ ExHandleTableUnlock

		return
	end

	auto entrysize
	4 entrysizelog@ << entrysize!

	auto entries
	handletablesrc@ ExHandleTableHeader_Entries + @ entries!

	entries@ handletable@ ExHandleTableHeader_Entries + !
	handletablesrc@ ExHandleTableHeader_FreeEntries + @ handletable@ ExHandleTableHeader_FreeEntries + !

	// copy initial table

	auto tabsize
	INITIALENTRIES entrysize@ * tabsize!

	handletable@ ExHandleTableHeader_SIZEOF + // dest
	handletablesrc@ ExHandleTableHeader_SIZEOF + // src
	tabsize@ // size
	memcpy

	auto tab
	handletablesrc@ ExHandleTableHeader_Table + @ tab!

	if (tab@)
		// we need to allocate and copy the extended table

		if (chargedprocess@)
			tab@ MmBlockChargeGet
			chargedprocess@ MmQuotaChargeProcess ok!

			if (ok@)
				// process does not have enough quota

				handletablesrc@ ExHandleTableUnlock

				// XXX careful with this call. the handle table is actually inconsistent here,
				// but this happens to work anyway without breaking ExHandleTableDelete. for now.
				0 handletable@ ExHandleTableDelete

				return
			end
		end

		INITIALENTRIES entries -=

		if (DEBUGCHECKS)
			if (entries@ 0 s<=)
				"ExHandleTableDuplicate: bad number of extended entries (0x%08x)\n" KeCrash
			end
		end

		entries@ entrysize@ * tabsize!

		auto newtab
		tabsize@ 'HnTd' MmAllocWithTag ok! newtab!

		if (ok@)
			if (chargedprocess@)
				tab@ MmBlockChargeGet
				chargedprocess@ MmQuotaUnchargeProcess
			end

			handletablesrc@ ExHandleTableUnlock

			// XXX careful with this call. the handle table is actually inconsistent here,
			// but this happens to work anyway without breaking ExHandleTableDelete. for now.
			0 handletable@ ExHandleTableDelete

			return
		end

		newtab@ // dest
		tab@ // src
		tabsize@ // size
		memcpy

		newtab@ handletable@ ExHandleTableHeader_Table + !		
	end

	auto i
	auto entryptr

	if (func@)
		// call a function for each handle

		0 i!

		handletable@ ExHandleTableHeader_Entries + @ entries!

		while (i@ entries@ <)
			i@
			handletable@
			1 // locked
			ExHandleLookup ok! entryptr!

			if (ok@ 0 ==)
				entryptr@ i@ handletable@ func@ ExHandleEnumFunction ok!

				if (ok@)
					// failed, delete handle

					0 entryptr@!
				end
			end

			1 i +=
		end
	end

	handletablesrc@ ExHandleTableUnlock
end

fn ExHandleTableCreate { chargedprocess entrysizelog -- handletable ok }
	auto entrysize
	4 entrysizelog@ << entrysize!

	auto tabsize
	ExHandleTableHeader_SIZEOF tabsize!

	auto tab0size
	INITIALENTRIES entrysize@ * tab0size!

	tab0size@ tabsize +=

	if (chargedprocess@)
		tabsize@ MmChargeBytesGet
		chargedprocess@ MmQuotaChargeProcess ok!

		if (ok@)
			return
		end
	end

	tabsize@ 'HnTb' MmAllocWithTag ok! handletable!

	if (ok@)
		// allocation failed

		if (chargedprocess@)
			tabsize@ MmChargeBytesGet
			chargedprocess@ MmQuotaUnchargeProcess
		end

		return
	end

	"HandleTableMutex" // name
	KERNELMODE // mode
	handletable@ ExHandleTableHeader_Mutex + // mutex
	KeMutexInitialize ok!

	if (ok@)
		"ExHandleTableCreate: mutex initialization failed\n" KeCrash
	end

	entrysizelog@ handletable@ ExHandleTableHeader_EntrySizeLog + !

	chargedprocess@ handletable@ ExHandleTableHeader_ChargedProcess + !

	INITIALENTRIES handletable@ ExHandleTableHeader_Entries + !
	INITIALENTRIES handletable@ ExHandleTableHeader_FreeEntries + !

	-1 handletable@ ExHandleTableHeader_RecycleHandle + !

	0 handletable@ ExHandleTableHeader_Table + !

	handletable@ ExHandleTableHeader_SIZEOF +
	tab0size@
	0
	memset
end

fn ExHandleTableLock { handletable -- ok }
	KERNELMODE // waitmode
	1 // alertable
	TIMEOUTINFINITE // timeout
	handletable@ ExHandleTableHeader_Mutex + // object
	KeThreadWaitForObject ok!
end

fn ExHandleTableUnlock { handletable -- }
	handletable@ ExHandleTableHeader_Mutex + KeMutexRelease drop
end

fn ExHandleDelete { handle handletable locked -- entryvalue ok }
	0 ok!

	if (locked@ ~~)
		handletable@ ExHandleTableLock ok!

		if (ok@)
			return
		end
	end

	auto entryptr

	handle@ // handle
	handletable@ // handletable
	1 // locked
	ExHandleLookup ok! entryptr!

	if (ok@)
		if (locked@ ~~)
			handletable@ ExHandleTableUnlock
		end

		return
	end

	entryptr@@ entryvalue!

	0 entryptr@!

	handle@ handletable@ ExHandleTableHeader_RecycleHandle + !

	1 handletable@ ExHandleTableHeader_FreeEntries + +=

	if (locked@ ~~)
		handletable@ ExHandleTableUnlock
	end
end

fn ExHandleCreate { entryvalue handletable locked -- handle entryptr ok }
	0 ok!

	if (DEBUGCHECKS)
		if (entryvalue@ ~~)
			"ExHandleCreate: entryvalue=0\n" KeCrash
		end
	end

	// lock handle table mutex

	if (locked@ ~~)
		handletable@ ExHandleTableLock ok!

		if (ok@)
			return
		end
	end

	auto chargedprocess
	handletable@ ExHandleTableHeader_ChargedProcess + @ chargedprocess!

	auto logsize
	handletable@ ExHandleTableHeader_EntrySizeLog + @ 2 + logsize!

	auto entries
	handletable@ ExHandleTableHeader_Entries + @ entries!

	auto tab
	handletable@ ExHandleTableHeader_Table + @ tab!

	handletable@ ExHandleTableHeader_RecycleHandle + @ handle!

	if (handle@ -1 ~=)
		// we can reuse the last freed handle instead of searching for one

		if (handle@ INITIALENTRIES <)
			handletable@ ExHandleTableHeader_SIZEOF +
			handle@ logsize@ << + entryptr!

			-1 handletable@ ExHandleTableHeader_RecycleHandle + !
		end else
			if (DEBUGCHECKS)
				if (tab@ ~~)
					"ExHandleCreate: table is null 1\n" KeCrash
				end
			end

			tab@ handle@ INITIALENTRIES - logsize@ << + entryptr!

			if (handle@ 1 + entries@ <)
				// its very common for there to be a free handle here.
				// if so, save it in RecycleHandle

				if (entryptr@ 1 logsize@ << + @ ~~)
					handle@ 1 + handletable@ ExHandleTableHeader_RecycleHandle + !
				end else
					-1 handletable@ ExHandleTableHeader_RecycleHandle + !
				end
			end else
				-1 handletable@ ExHandleTableHeader_RecycleHandle + !
			end
		end

		if (DEBUGCHECKS)
			if (entryptr@@)
				"ExHandleCreate: recyclable handle was already used\n" KeCrash
			end
		end

		entryvalue@ entryptr@!

		1 handletable@ ExHandleTableHeader_FreeEntries + -=

		if (locked@ ~~)
			handletable@ ExHandleTableUnlock
		end

		return
	end

	0 handle!

	auto tabsize
	EXTENDBYENTRIES logsize@ << tabsize!

	if (handletable@ ExHandleTableHeader_FreeEntries + @ ~~)
		// create or grow the extended table

		if (tab@ ~~)
			// create

			if (chargedprocess@)
				tabsize@ MmChargeBytesGet
				chargedprocess@ MmQuotaChargeProcess ok!

				if (ok@)
					// insufficient quota

					if (locked@ ~~)
						handletable@ ExHandleTableUnlock
					end

					return
				end
			end

			tabsize@ 'HnTd' MmAllocWithTag ok! tab!

			if (ok@)
				// allocation failed

				if (chargedprocess@)
					tabsize@ MmChargeBytesGet
					chargedprocess@ MmQuotaUnchargeProcess
				end

				if (locked@ ~~)
					handletable@ ExHandleTableUnlock
				end

				return
			end

			tab@ handletable@ ExHandleTableHeader_Table + !

			tab@
			tabsize@
			0
			memset

			EXTENDBYENTRIES entries +=

			INITIALENTRIES handle! // start search at extended table
		end else
			// grow

			entries@ handle! // start search at new entries

			EXTENDBYENTRIES entries +=

			entries@ INITIALENTRIES - logsize@ << tabsize!

			if (chargedprocess@)
				// BUGBUG there is a race condition here where the process's quota
				// may become inconsistent if a charge is allowed to succeed in the middle
				// of this operation!! should be reworked so that we only ever charge & uncharge
				// the whole new chunk at once

				// we do this in a weird way.
				// first we uncharge the quota for the extended table,
				// then we re-charge the quota for the new size of the extended table.

				tab@ MmBlockChargeGet
				chargedprocess@ MmQuotaUnchargeProcess

				tabsize@ MmChargeBytesGet
				chargedprocess@ MmQuotaChargeProcess ok!

				if (ok@)
					// insufficient quota

					// re-charge the quota for the old size of the extended table.

					tab@ MmBlockChargeGet
					chargedprocess@ MmQuotaChargeProcess drop

					if (locked@ ~~)
						handletable@ ExHandleTableUnlock
					end

					return
				end
			end

			auto newtab
			tabsize@ 'HnTd' MmAllocWithTag ok! newtab!

			if (ok@)
				// allocation failed

				if (chargedprocess@)
					// undo the shenanigans we just did with the quota charge

					tabsize@ MmChargeBytesGet
					chargedprocess@ MmQuotaUnchargeProcess

					tab@ MmBlockChargeGet
					chargedprocess@ MmQuotaChargeProcess drop
				end

				if (locked@ ~~)
					handletable@ ExHandleTableUnlock
				end

				return
			end

			newtab@
			tab@
			entries@ INITIALENTRIES - EXTENDBYENTRIES - logsize@ <<
			memcpy

			newtab@ entries@ INITIALENTRIES - EXTENDBYENTRIES - logsize@ << +
			EXTENDBYENTRIES logsize@ <<
			0
			memset

			tab@ MmFree

			newtab@ tab!

			tab@ handletable@ ExHandleTableHeader_Table + !
		end

		EXTENDBYENTRIES handletable@ ExHandleTableHeader_FreeEntries + !

		entries@ handletable@ ExHandleTableHeader_Entries + !
	end

	auto entrysize
	1 logsize@ << entrysize!

	if (handle@ INITIALENTRIES <)
		// search initial table first

		handletable@ ExHandleTableHeader_SIZEOF +
		handle@ logsize@ << + entryptr!

		while (handle@ INITIALENTRIES <)
			if (entryptr@@ ~~)
				entryvalue@ entryptr@!

				1 handletable@ ExHandleTableHeader_FreeEntries + -=

				if (locked@ ~~)
					handletable@ ExHandleTableUnlock
				end

				return
			end

			entrysize@ entryptr +=
			1 handle +=
		end
	end

	if (DEBUGCHECKS)
		if (tab@ ~~)
			"ExHandleCreate: table is null 2\n" KeCrash
		end
	end

	handle@ INITIALENTRIES - logsize@ << tab@ + entryptr!

	while (handle@ entries@ <)
		if (entryptr@@ ~~)
			if (handle@ 1 + entries@ <)
				// its very common for there to be a free handle here.
				// if so, save it in RecycleHandle

				if (entryptr@ 1 logsize@ << + @ ~~)
					handle@ 1 + handletable@ ExHandleTableHeader_RecycleHandle + !
				end
			end

			entryvalue@ entryptr@!

			1 handletable@ ExHandleTableHeader_FreeEntries + -=

			if (locked@ ~~)
				handletable@ ExHandleTableUnlock
			end

			return
		end

		entrysize@ entryptr +=
		1 handle +=
	end

	"ExHandleCreate: there should have been free entries\n" KeCrash
end

fn ExHandleLookup { handle handletable locked -- entryptr ok }
	0 ok!

	if (locked@ ~~)
		handletable@ ExHandleTableLock ok!

		if (ok@)
			return
		end
	end

	auto logsize
	handletable@ ExHandleTableHeader_EntrySizeLog + @ 2 + logsize!

	auto entries
	handletable@ ExHandleTableHeader_Entries + @ entries!

	if (handle@ entries@ >=)
		if (locked@ ~~)
			handletable@ ExHandleTableUnlock
		end

		STATUS_INVALID_HANDLE ok!

		return
	end

	if (handle@ INITIALENTRIES <)
		handletable@ ExHandleTableHeader_SIZEOF +
		handle@ logsize@ << + entryptr!
	end else
		auto tab
		handletable@ ExHandleTableHeader_Table + @ tab!

		if (DEBUGCHECKS)
			if (tab@ ~~)
				"ExHandleLookup: table is null\n" KeCrash
			end
		end

		INITIALENTRIES handle -=

		tab@ handle@ logsize@ << + entryptr!
	end

	if (entryptr@@ ~~)
		STATUS_INVALID_HANDLE ok!
	end

	if (locked@ ~~)
		handletable@ ExHandleTableUnlock
	end
end
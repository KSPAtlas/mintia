#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALDebug.h"

buffer TestThread1Stack KETHREADSTACKSIZE
buffer TestThread2Stack KETHREADSTACKSIZE

buffer TestThread1 KeThread_SIZEOF

buffer TestThread2 KeThread_SIZEOF

buffer TestAPC KeAPC_SIZEOF

buffer TestMutex KeMutex_SIZEOF

buffer TestMutex2 KeMutex_SIZEOF

buffer TestEvent KeEvent_SIZEOF

fn (APCFunctionKernel) TestKernelFunc { normalfunc context1 context2 apc -- }
	// context2@@ context1@@ KeThreadCurrent@ KeThread_Name + "hi im in %s context. c1=%d c2=%d\n" Printf
end

fn (APCFunctionNormal) TestNormalFunc { context1 context2 -- }
	// context2@ context1@ KeThreadCurrent@ KeThread_Name + "hi im in %s context! c1=%d c2=%d\n" Printf

	// HALDebug drop
	SierpinskiFast

	// 600 KERNELMODE 0 KeThreadSleep drop
end

fn ExInitPhase0 { -- }
	// initialize physical memory allocation

	MmInitPhase0

	// do some random tests

	0xBBBBBBBB
	'o'
	pointerof TestKernelThread
	KeProcessKernelProcess // process
	TestThread1Stack // kstack
	"bthread"
	TestThread1
	KeThreadInitialize drop

	0xCCCCCCCC
	'c'
	pointerof TestKernelThread
	KeProcessKernelProcess // process
	TestThread2Stack // kstack
	"cthread"
	TestThread2
	KeThreadInitialize drop

	// PRIORITY_LOWREALTIME TestThread2 KeThread_BasePriority + !
	// PRIORITY_LOWREALTIME TestThread2 KeThread_Priority + !

	0 KEEVENT_NOTIF "testevent" TestEvent KeEventInitialize drop

	TestThread2    // target thread
	0              // exit func
	pointerof TestKernelFunc // kernel func
	pointerof TestNormalFunc // normal func
	KERNELMODE     // mode
	TestAPC
	KeAPCInitialize drop

	"testmutex" KERNELMODE TestMutex KeMutexInitialize drop

	"testmutex2" KERNELMODE TestMutex2 KeMutexInitialize drop

	// QUEUEBACK TestThread1 KeThreadReady
	// QUEUEBACK TestThread2 KeThreadReady

	auto ok
	auto handletable

	0 0 ExHandleTableCreate ok! handletable!

	auto handle
	auto entryptr

	"making tons of handles\n" Printf

	auto i
	0 i!

	while (i@ 65536 <)
		10
		handletable@
		1 // locked
		ExHandleCreate ok! entryptr! handle!

		if (ok@)
			ok@ "%i\n" Printf

			HALDebug drop

			break
		end

		if (i@ 0xFF & ~~)
			i@ "%d " Printf
			// MemHeapCheck
		end

		// handle@
		// handletable@
		// 1
		// ExHandleDelete ok!

		// ok@ entryptr@ handle@ "handle=%d entryptr=%08x ok=%d\n" Printf

		1 i +=
	end

	0 handletable@ ExHandleTableDelete ok!

	if (ok@)
		ok@ "delete %i\n" Printf

		HALDebug

		drop
	end

	0 0 ExHandleTableCreate ok! handletable!

	if (ok@)
		ok@ "create %i\n" Printf

		HALDebug

		drop
	end

	0 i!

	while (i@ 65536 <)
		10
		handletable@
		0 // locked
		ExHandleCreate ok! entryptr! handle!

		if (ok@)
			ok@ "%i\n" Printf

			HALDebug drop

			break
		end

		if (i@ 0xFF & ~~)
			i@ "%d " Printf
			// MemHeapCheck
		end

		// handle@
		// handletable@
		// 1
		// ExHandleDelete ok!

		// ok@ entryptr@ handle@ "handle=%d entryptr=%08x ok=%d\n" Printf

		1 i +=
	end

	MmHeapDumpBuckets

	MmHeapCheck
end

asm "

SierpinskiCount:
	.dl 0

SierpinskiIter:
	.dl 0

SierpinskiFast:
.global SierpinskiFast
	push lr
	push s0
	push s1
	push s2
	push s3
	push s4
	push s5
	push s6
	push s7

	li s0, 0

	li s1, 126

	li s5, 15877

	li s7, 640

	la  s2, SierpinskiIter
	mov s3, long [s2]

	la  t0, SierpinskiCount
	mov s4, long [t0]

	lui s6, 0xC0100000

.loop:
	div t1, s0, s1
	mod t2, s0, s1

	and t3, t1, t2
	bne t3, zero, .cont

	rsh a2, t2, 1
	not a2, a2
	sub a2, t1, a2

	sub a1, s1, t2

	xor a0, t1, s4
	xor a0, a0, s3
	xor a0, a0, t2

	mul t0, a1, s7
	lsh t0, t0, 1
	lsh a2, a2, 1
	add t0, t0, a2
	mov int [s6 + t0], a0

	add s3, s3, 1

.cont:
	add s0, s0, 1

	blt s0, s5, .loop

	mov long [s2], s3

	add s4, s4, 1

	la  t0, SierpinskiCount
	mov long [t0], s4
	
	pop s7
	pop s6
	pop s5
	pop s4
	pop s3
	pop s2
	pop s1
	pop s0
	pop lr
	ret

"

extern SierpinskiFast { -- }

fn TestKernelThread { context1 context2 -- }
	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	if (context1@ 0xCCCCCCCC ==)
		3000 KERNELMODE 0 KeThreadSleep drop

		0 TestEvent KeEventSignal drop
	end

	while (1)
		auto ok

		if (context1@ 0xCCCCCCCC ==)
			// 3000 KERNELMODE 0 KeThreadSleep drop

			KERNELMODE WAITUNALERTABLE TIMEOUTINFINITE TestMutex KeThreadWaitForObject drop

			"cccc" Printf

			HALCPUHalt

			TestMutex KeMutexRelease drop

			// 1000 KERNELMODE 0 KeThreadSleep drop
		end else
			// 3000 KERNELMODE 0 KeThreadSleep drop

			KERNELMODE WAITUNALERTABLE TIMEOUTINFINITE TestMutex KeThreadWaitForObject drop

			"bbbb" Printf

			// 600 KERNELMODE 0 KeThreadSleep drop

			// if (TestAPC KeAPC_Enqueued + @ ~~)
			//	0 0 0 TestAPC KeAPCEnqueue drop
			// end

			HALCPUHalt

			TestMutex KeMutexRelease drop
		end
	end
end
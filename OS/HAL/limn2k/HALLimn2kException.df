#include "<df>/dragonfruit.h"
#include "<inc>/HALLimn2kContext.h"
#include "<inc>/HALCrash.h"

#include "<inc>/HALCPU.h"

const ECAUSEINTERRUPT 1

externptr HALLIMNstationInterruptHandlers

externptr HALLIMNstationLSICClaimComplete

var HALInterruptFunction 0
public HALInterruptFunction

var HALThreadCurrentStackTop 0
public HALThreadCurrentStackTop

asm "

HALLimn2kExceptionVector:
.global HALLimn2kExceptionVector
	mov    k2, sp                           ; save old sp in k2,
	                                        ; this could be a usermode sp, in which case it needs saving,
	                                        ; or a kernel mode sp, in which case we'll keep using it,
	                                        ; but it's much easier and faster to save it unconditionally,
	                                        ; instead of trying to figure it out.

	mov    k0, k2                           ; save stack link

	andi   k1, ers,  RS_USER                ; if the code that just got interrupted was kernel code,
	beq    k1, zero, .waskernel             ; don't switch stacks, continue using the kernel mode stacks
	                                        ; for this thread.

	la     k0, HALThreadCurrentStackTop
	l.l    sp, k0, zero                     ; switch to the kernel stack for the current thread

	mov    k0, zero                         ; this sp is a usermode sp, making it meaningless for stack traces.
	                                        ; turn it into a zero link to stop the debugger from freaking out if
	                                        ; it tries to trace past this vector.

.waskernel:

	subi.i sp, Limn2kContext_SIZEOF         ; reserve space in stack for context save
	sio.l  sp, Limn2kContext_sp,  k2        ; store the saved sp from above's longwinded comment
	sio.l  sp, Limn2kContext_ers, ers       ; store the interrupted thread's processor mode
	sio.l  sp, Limn2kContext_epc, epc       ; store the interrupted thread's program counter
	sio.l  sp, Limn2kContext_lr,  lr        ; store the interrupted thread's return address register
	sgpr   sp                               ; save the rest of the general purpose registers
	                                        ; what a convenient instruction sgpr is

	beqi   ecause, ECAUSEINTERRUPT, .interrupt ; if the exception was an interrupt, jump to the fast-track code for that

	mov    a2, badaddr
	mov    a1, ecause
	mov    a0, sp                           ; give HALLimn2kException our context

	push   epc                              ; set up a fake stack frame stub so that the debugger's stack trace doesn't freak out here
	push   k0

	jal    HALLimn2kException               ; call HALLimn2kException, to handle the exception

	li     badaddr, 0                       ; clear badaddr because the processor doesn't do it for us

	addi.i sp, 8                            ; unwind the fake stack frame stub we added

	lgpr   sp                               ; restore general purpose registers
	lio.l  ers, sp, Limn2kContext_ers       ; restore interrupted thread's processor mode
	lio.l  epc, sp, Limn2kContext_epc       ; restore interrupted thread's program counter
	lio.l  lr,  sp, Limn2kContext_lr        ; restore interrupted thread's return address register
	lio.l  sp,  sp, Limn2kContext_sp        ; restore interrupted thread's stack pointer, just in case
	                                        ; it was user code

	rfe                                     ; give control back to the thread

.interrupt:

	push   epc                              ; set up a fake stack frame stub so that the debugger's stack trace doesn't freak out here
	push   zero

	la     s2, HALInterruptFunction         ; get the address of the kernel's interrupt dispatcher
	l.l    s2, s2, zero

	la     s0, HALLIMNstationLSICClaimComplete ; get the address of the interrupt controller's claim/complete register
	l.l    s0, s0, zero

	la     s1, HALLIMNstationInterruptHandlers ; get the base address of the interrupt handler table

	l.l    t0, s0, zero                     ; get the first interrupt number from the claim/complete register

	beq    t0, zero, .interruptsdone        ; skip to the end if there somehow wasn't one

.nextinterrupt:

	lshi   t1, t0, 3                        ; multiply the interrupt number by 8 to get a table offset
	add    t1, s1, t1                       ; add to the interrupt handler table base
	lio.l  a2, t1, 4                        ; get the interrupt's priority level
	l.l    a0, t1, zero                     ; get the handler address

	s.l    s0, zero, t0                     ; ACK the interrupt by writing it back to the claim/complete register

	mov    a1, t0                           ; pass the interrupt number
	jalr   s2                               ; jump to the kernel's interrupt dispatcher

	l.l    t0, s0, zero                     ; get the next interrupt number
	bne    t0, zero, .nextinterrupt         ; if there is an interrupt, restart the loop

.interruptsdone:

	addi   sp, sp, 8                        ; unwind the fake stack frame stub we added

	lgpr   sp                               ; restore general purpose registers
	lio.l  ers, sp, Limn2kContext_ers       ; restore interrupted thread's processor mode
	lio.l  epc, sp, Limn2kContext_epc       ; restore interrupted thread's program counter
	lio.l  lr,  sp, Limn2kContext_lr        ; restore interrupted thread's return address register
	lio.l  sp,  sp, Limn2kContext_sp        ; restore interrupted thread's stack pointer, just in case
	                                        ; it was user code

	rfe                                     ; give control back to the thread

HALLimn2kExceptionRefillVector:
.global HALLimn2kExceptionRefillVector
	rfe

; -- sp
HALCPUGetSP:
.global HALCPUGetSP
	mov v0, sp
	ret

; -- rs
HALCPUInterruptDisable:
.global HALCPUInterruptDisable
	mov v0, rs
	bclri rs, rs, 3
	bclri rs, rs, 1
	ret

; rs --
HALCPUInterruptRestore:
.global HALCPUInterruptRestore
	mov rs, a0
	ret

; --
HALCPUInterruptEnable:
.global HALCPUInterruptEnable
	bseti rs, rs, 1
	ret

; old new -- 
HALCPUContextSwitch:
.global HALCPUContextSwitch
	subi.i sp, Limn2kContext_SIZEOF
	sio.l  sp, Limn2kContext_sp,  sp
	sio.l  sp, Limn2kContext_epc, lr
	sio.l  sp, Limn2kContext_lr,  lr
	sio.l  sp, Limn2kContext_ers, rs
	sgpr   sp

	s.l    a1, zero, sp
	mov    sp, a0

	lgpr   sp
	lio.l  lr,    sp,   Limn2kContext_lr
	lio.l  rs,    sp,   Limn2kContext_ers
	addi.i sp,    Limn2kContext_SIZEOF

	ret

; int handler stack --
HALCPURunInContext:
.global HALCPURunInContext
	mov t0, sp
	mov sp, a0

	push lr
	push t0

	bseti rs, rs, 1

	mov a0, a2

	jalr a1

	bclri rs, rs, 1

	pop t0
	pop lr

	mov sp, t0

	ret

"

const EXCNAMESMAX 13

table ExceptionNames
	"NOTHING"
	"INTERRUPT"
	"SYSCALL"
	"TLBREFILL"
	"BUSERROR"
	"TIMER"
	"BREAKPOINT"
	"INVALIDOPCODE"
	"PRIVILEGEVIOLATION"
	"UNALIGNEDADDR"
	"UNALIGNEDPC"
	"DIVBYZERO"
	"PAGEFAULT(ACCESS)"
	"PAGEFAULT(INVALID)"
endtable

fn HALLimn2kException { badaddr ecause tf -- }
	auto excname

	if (ecause@ EXCNAMESMAX >)
		"UNKNOWN" excname!
	end else
		[ecause@]ExceptionNames@ excname!
	end

	ecause@ excname@ badaddr@ tf@ Limn2kContext_epc + @ tf@ Limn2kContext_ers + @
	"Fault: ERS=%08x EPC=%08x BADADDR=%08x ECAUSE=%s (%d)\n" HALCrash

	// while (1) end
end

fn HALCPUContextInit { context1 context2 startfunc kstack -- ctx }
	8 kstack -=

	0 kstack@!
	startfunc@ kstack@ 4 + !

	kstack@ Limn2kContext_SIZEOF - ctx!

	ctx@ Limn2kContext_SIZEOF 0 memset

	context1@ ctx@ Limn2kContext_a1 + !
	context2@ ctx@ Limn2kContext_a0 + !

	RS_INT ctx@ Limn2kContext_ers + !

	startfunc@ ctx@ Limn2kContext_lr + !
end
#include "<df>/dragonfruit.h"
#include "<inc>/HALLimn2kContext.h"
#include "<inc>/HALCrash.h"

const ECAUSEINTERRUPT 1

externptr HALLIMNstationInterruptHandlers

externptr HALLIMNstationLSICClaimComplete

var HALInterruptFunction 0
public HALInterruptFunction

asm "

HALLimn2kExceptionVector:
.global HALLimn2kExceptionVector
	mov   k2, sp ; save old sp in k2,
	             ; this could be a usermode sp, in which case it needs saving,
	             ; or a kernel mode sp, in which case we'll keep using it,
	             ; but it's much easier and faster to save it unconditionally,
	             ; instead of trying to figure it out.

	mov   k0, k2 ; save stack link

	andi  k1, ers,  RS_USER    ; if the code that just got interrupted was kernel code,
	beq   k1, zero, .waskernel ; don't switch stacks, continue using the kernel mode stacks
	                           ; for this thread.

	; la    k0, CurrentThread
	; l.l   k0, k0, zero      ; k0 = [CurrentThread]
	; lio.l sp, k0, Thread_KernelStackTop ; load new sp from the current thread's structure

	mov    k0, zero ; this sp is a usermode sp, making it meaningless for stack traces.
	                ; turn it into a zero link.

.waskernel:
	subi.i sp, Limn2kContext_SIZEOF   ; reserve space in stack for context save
	sio.l  sp, Limn2kContext_sp,  k2  ; store the saved sp from above's longwinded comment
	sio.l  sp, Limn2kContext_ers, ers ; store the interrupted thread's processor mode
	sio.l  sp, Limn2kContext_epc, epc ; store the interrupted thread's program counter
	sio.l  sp, Limn2kContext_lr,  lr  ; store the interrupted thread's return address register
	sgpr   sp                         ; save the rest of the general purpose registers
	                                  ; what a convenient instruction sgpr is

	beqi   ecause, ECAUSEINTERRUPT, .interrupt

	mov    a2, badaddr
	mov    a1, ecause
	mov    a0, sp                     ; give HALLimn2kException our context

	push   epc                        ; save epc
	push   k0                         ; save sp or zero link

	jal    HALLimn2kException         ; call HALLimn2kException, to handle the exception

	li     badaddr, 0                 ; clear badaddr because the processor doesn't do it for us

	addi.i sp, 8                      ; unwind the debug stuff we added

	lgpr  sp                          ; restore general purpose registers
	lio.l ers, sp, Limn2kContext_ers  ; restore interrupted thread's processor mode
	lio.l epc, sp, Limn2kContext_epc  ; restore interrupted thread's program counter
	lio.l lr,  sp, Limn2kContext_lr   ; restore interrupted thread's return address register
	lio.l sp,  sp, Limn2kContext_sp   ; restore interrupted thread's stack pointer, just in case
	                                  ; it was user code

	rfe ; give control back to the thread

.interrupt:
	push epc
	push zero

	la  s2, HALInterruptFunction
	l.l s2, s2, zero

	la  s0, HALLIMNstationLSICClaimComplete
	l.l s0, s0, zero

	la  s1, HALLIMNstationInterruptHandlers

	l.l t0, s0, zero

	beq t0, zero, .interruptsdone

.nextinterrupt:
	lshi  t1, t0, 3
	add   t1, s1, t1
	lio.l t2, t1, 4
	l.l   t1, t1, zero

	s.l s0, zero, t0

	mov  a2, t2
	mov  a1, t0
	mov  a0, t1
	jalr s2

	l.l t0, s0, zero
	bne t0, zero, .nextinterrupt

.interruptsdone:
	addi.i sp, 8

	lgpr  sp                          ; restore general purpose registers
	lio.l ers, sp, Limn2kContext_ers  ; restore interrupted thread's processor mode
	lio.l epc, sp, Limn2kContext_epc  ; restore interrupted thread's program counter
	lio.l lr,  sp, Limn2kContext_lr   ; restore interrupted thread's return address register
	lio.l sp,  sp, Limn2kContext_sp   ; restore interrupted thread's stack pointer, just in case
	                                  ; it was user code

	rfe ; give control back to the thread

HALLimn2kExceptionRefillVector:
.global HALLimn2kExceptionRefillVector
	rfe

; -- sp
HALCPUGetSP:
.global HALCPUGetSP
	mov v0, sp
	ret

; -- rs
HALCPUInterruptDisable:
.global HALCPUInterruptDisable
	mov v0, rs
	bclri rs, rs, 3
	bclri rs, rs, 1
	ret

; rs --
HALCPUInterruptRestore:
.global HALCPUInterruptRestore
	mov rs, a0
	ret

; --
HALCPUInterruptEnable:
.global HALCPUInterruptEnable
	bseti rs, rs, 1
	ret

"

const EXCNAMESMAX 13

table ExceptionNames
	"NOTHING"
	"INTERRUPT"
	"SYSCALL"
	"TLBREFILL"
	"BUSERROR"
	"TIMER"
	"BREAKPOINT"
	"INVALIDOPCODE"
	"PRIVILEGEVIOLATION"
	"UNALIGNEDADDR"
	"UNALIGNEDPC"
	"DIVBYZERO"
	"PAGEFAULT(ACCESS)"
	"PAGEFAULT(INVALID)"
endtable

fn HALLimn2kException { badaddr ecause tf -- }
	auto excname

	if (ecause@ EXCNAMESMAX >)
		"UNKNOWN" excname!
	end else
		[ecause@]ExceptionNames@ excname!
	end

	ecause@ excname@ badaddr@ tf@ Limn2kContext_epc + @ "Unexpected fault: EPC=%08x BADADDR=%08x ECAUSE=%s (%d)\n" HALCrash

	// while (1) end
end
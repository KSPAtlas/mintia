#include "<df>/dragonfruit.h"
#include "<inc>/HALLimn2kContext.h"
#include "<inc>/HALCrash.h"

#include "<inc>/HALCPU.h"

const ECAUSEINTERRUPT 1

externptr HALLIMNstationInterruptHandlers

externptr HALLIMNstationLSICClaimComplete

var HALInterruptFunction 0
public HALInterruptFunction

var HALThreadCurrentStackTop 0
public HALThreadCurrentStackTop

asm "

HALLimn2kExceptionVector:
.global HALLimn2kExceptionVector
	mov    k2, sp                           ; save old sp in k2,
	                                        ; this could be a usermode sp, in which case it needs saving,
	                                        ; or a kernel mode sp, in which case we'll keep using it,
	                                        ; but it's much easier and faster to save it unconditionally,
	                                        ; instead of trying to figure it out.

	mov    k0, k2                           ; save stack link

	and    k1, ers,  RS_USER                ; if the code that just got interrupted was kernel code,
	beq    k1, zero, .waskernel             ; don't switch stacks, continue using the kernel mode stacks
	                                        ; for this thread.

	la     k0, HALThreadCurrentStackTop
	mov    sp, long [k0]                    ; switch to the kernel stack for the current thread

	mov    k0, zero                         ; this sp is a usermode sp, making it meaningless for stack traces.
	                                        ; turn it into a zero link to stop the debugger from freaking out if
	                                        ; it tries to trace past this vector.

.waskernel:

	sub sp, Limn2kContext_SIZEOF           ; reserve space in stack for context save
	mov long [sp + Limn2kContext_sp],  k2  ; store the saved sp from above's longwinded comment
	mov long [sp + Limn2kContext_ers], ers ; store the interrupted thread's processor mode
	mov long [sp + Limn2kContext_epc], epc ; store the interrupted thread's program counter
	mov long [sp + Limn2kContext_lr],  lr  ; store the interrupted thread's return address register
	sgpr sp                                ; save the rest of the general purpose registers
	                                       ; what a convenient instruction sgpr is

	beq    ecause, ECAUSEINTERRUPT, .interrupt ; if the exception was an interrupt, jump to the fast-track code for that

	mov    a2, badaddr
	mov    a1, ecause
	mov    a0, sp                           ; give HALLimn2kException our context

	push   epc                              ; set up a fake stack frame stub so that the debugger's stack trace doesn't freak out here
	push   k0

	jal    HALLimn2kException               ; call HALLimn2kException, to handle the exception

	li     badaddr, 0                       ; clear badaddr because the processor doesn't do it for us

	add    sp, 8                            ; unwind the fake stack frame stub we added

	lgpr sp                                 ; restore general purpose registers
	mov  ers, long [sp + Limn2kContext_ers] ; restore interrupted thread's processor mode
	mov  epc, long [sp + Limn2kContext_epc] ; restore interrupted thread's program counter
	mov  lr,  long [sp + Limn2kContext_lr]  ; restore interrupted thread's return address register
	mov  sp,  long [sp + Limn2kContext_sp]  ; restore interrupted thread's stack pointer, just in case
	                                        ; it was user code

	rfe                                     ; give control back to the thread

.interrupt:

	push   epc                              ; set up a fake stack frame stub so that the debugger's stack trace doesn't freak out here
	push   zero

	la     s2, HALInterruptFunction         ; get the address of the kernel's interrupt dispatcher
	mov    s2, long [s2]

	la     s0, HALLIMNstationLSICClaimComplete ; get the address of the interrupt controller's claim/complete register
	mov    s0, long [s0]

	la     s1, HALLIMNstationInterruptHandlers ; get the base address of the interrupt handler table

	mov    t0, long [s0]                    ; get the first interrupt number from the claim/complete register

	beq    t0, zero, .interruptsdone        ; skip to the end if there somehow wasn't one

.nextinterrupt:

	lsh    t1, t0, 3                        ; multiply the interrupt number by 8 to get a table offset
	add    t1, s1, t1                       ; add to the interrupt handler table base
	mov    a2, long [t1 + 4]                ; get the interrupt's priority level
	mov    a0, long [t1]                    ; get the handler address

	mov    long [s0], t0                    ; ACK the interrupt by writing it back to the claim/complete register

	mov    a1, t0                           ; pass the interrupt number
	jal    s2                               ; jump to the kernel's interrupt dispatcher

	mov    t0, long [s0]                    ; get the next interrupt number
	bne    t0, zero, .nextinterrupt         ; if there is an interrupt, restart the loop

.interruptsdone:

	add    sp, sp, 8                        ; unwind the fake stack frame stub we added

	lgpr sp                                 ; restore general purpose registers
	mov  ers, long [sp + Limn2kContext_ers] ; restore interrupted thread's processor mode
	mov  epc, long [sp + Limn2kContext_epc] ; restore interrupted thread's program counter
	mov  lr,  long [sp + Limn2kContext_lr]  ; restore interrupted thread's return address register
	mov  sp,  long [sp + Limn2kContext_sp]  ; restore interrupted thread's stack pointer, just in case
	                                        ; it was user code

	rfe                                     ; give control back to the thread

HALLimn2kExceptionRefillVector:
.global HALLimn2kExceptionRefillVector
	rfe

; -- sp
HALCPUGetSP:
.global HALCPUGetSP
	mov v0, sp
	ret

; -- rs
HALCPUInterruptDisable:
.global HALCPUInterruptDisable
	mov v0, rs
	bclr rs, rs, 3
	bclr rs, rs, 1
	ret

; rs --
HALCPUInterruptRestore:
.global HALCPUInterruptRestore
	mov rs, a0
	ret

; --
HALCPUInterruptEnable:
.global HALCPUInterruptEnable
	bset rs, rs, 1
	ret

; old new -- 
HALCPUContextSwitch:
.global HALCPUContextSwitch
	sub sp, Limn2kContext_SIZEOF
	mov long [sp + Limn2kContext_sp],    sp
	mov long [sp + Limn2kContext_epc],   lr
	mov long [sp + Limn2kContext_lr],    lr
	mov long [sp + Limn2kContext_ers],   rs
	sgpr    sp

	mov     long [a1], sp
	mov     sp, a0

	lgpr    sp
	mov lr, long [sp + Limn2kContext_lr]
	mov rs, long [sp + Limn2kContext_ers]
	add sp, Limn2kContext_SIZEOF

	ret

; int handler stack --
HALCPURunInContext:
.global HALCPURunInContext
	mov t0, sp
	mov sp, a0

	push lr
	push t0

	bset rs, rs, 1

	mov a0, a2

	jal a1

	bclr rs, rs, 1

	pop t0
	pop lr

	mov sp, t0

	ret

"

const EXCNAMESMAX 13

table ExceptionNames
	"NOTHING"
	"INTERRUPT"
	"SYSCALL"
	"TLBREFILL"
	"BUSERROR"
	"TIMER"
	"BREAKPOINT"
	"INVALIDOPCODE"
	"PRIVILEGEVIOLATION"
	"UNALIGNEDADDR"
	"UNALIGNEDPC"
	"DIVBYZERO"
	"PAGEFAULT(ACCESS)"
	"PAGEFAULT(INVALID)"
endtable

fn HALLimn2kException { badaddr ecause tf -- }
	auto excname

	if (ecause@ EXCNAMESMAX >)
		"UNKNOWN" excname!
	end else
		[ecause@]ExceptionNames@ excname!
	end

	ecause@ excname@ badaddr@ tf@ Limn2kContext_epc + @ tf@ Limn2kContext_ers + @
	"Fault: ERS=%08x EPC=%08x BADADDR=%08x ECAUSE=%s (%d)\n" HALCrash

	// while (1) end
end

fn HALCPUContextInit { context1 context2 startfunc kstack -- ctx }
	8 kstack -=

	0 kstack@!
	startfunc@ kstack@ 4 + !

	kstack@ Limn2kContext_SIZEOF - ctx!

	ctx@ Limn2kContext_SIZEOF 0 memset

	context1@ ctx@ Limn2kContext_a1 + !
	context2@ ctx@ Limn2kContext_a0 + !

	RS_INT ctx@ Limn2kContext_ers + !

	startfunc@ ctx@ Limn2kContext_lr + !
end